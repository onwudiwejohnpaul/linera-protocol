searchState.loadedDescShard("alloy_consensus", 0, "alloy-consensus\nRepresents an TrieAccount in the account trie.\nA Blob serialized as 0x-prefixed hex string\nThis represents a set of blobs, and its corresponding …\nEthereum full block.\nA response to <code>GetBlockBodies</code>, containing bodies if any …\nTrait for extracting specific Ethereum block data from a …\nA commitment/proof serialized as 0x-prefixed hex string\nRoot hash of an empty trie.\nReceipt envelope with type flag 2, containing a EIP-1559 …\nReceipt type that knows its EIP-2718 encoding.\nReceipt envelope with type flag 1, containing a EIP-2930 …\nReceipt envelope with type flag 2, containing a EIP-4844 …\nA boolean <code>statusCode</code> introduced by EIP-658.\nCaptures the result of a transaction execution.\nReceipt envelope with type flag 4, containing a EIP-7702 …\nEthereum Block header\nReceipt envelope with no type flag.\nThe associated log type.\nA pre-EIP-658 hash value.\nReceipt containing result of transaction execution.\nReceipt envelope, as defined in EIP-2718.\n<code>Receipt</code> with calculated bloom filter.\nReceipt containing result of transaction execution.\nReceipt type that knows how to decode itself with a <code>Bloom</code> …\nReceipt type that knows how to encode itself with a <code>Bloom</code> …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nBuild a <code>BlobTransactionSidecar</code> from an arbitrary amount of …\nA strategy for coding and decoding data into sidecars.\nA transaction with a signature and hash seal.\nSimple coder that only uses the last 31 bytes of each …\nRepresents an TrieAccount in the account trie.\nReceipt is the result of a transaction execution.\nFallibly convert to the EIP-658 status code.\nFallibly convert to the post state.\nReturn the inner receipt. Currently this is infallible, …\nReturn the inner receipt with bloom. Currently this is …\nConverts from <code>&amp;Sealed&lt;T&gt;</code> to <code>Sealed&lt;&amp;T&gt;</code>.\nThe account’s balance.\nThe account’s balance.\nRetrieves the base fee per gas of the block, if available\nA scalar representing EIP1559 base fee which can move up …\nRetrieves the beneficiary (miner) of the block\nThe 160-bit address to which all fees collected from the …\nReturns the blob fee for <em>this</em> block according to the …\nReturns the blob fee for <em>this</em> block according to the …\nReturns the blob fee for <em>this</em> block according to the …\nRetrieves the blob gas used by the block, if available\nThe total amount of blob gas consumed by the transactions …\nReturns an iterator over all blob versioned hashes from …\nThe blob data.\nReturns the bloom filter for the logs in the receipt. This …\nReturn the receipt’s bloom.\nReturns the bloom filter for the logs in the receipt, if …\nReturns the bloom filter for the logs in the receipt, if …\nCalculates <code>Log</code>’s bloom filter. this is slow operation …\nBlock body.\nCalculate the ommers root for the block body.\nCalculate the withdrawals root for the block body, if …\nClone the inner item.\nMaps a <code>Sealed&lt;&amp;T&gt;</code> to a <code>Sealed&lt;T&gt;</code> by cloning the inner …\nCode a slice of data into the builder.\nThe hash of the code of the account.\nThe hash of the code of the account.\nReturns true if the transaction was successful OR if the …\nThe blob commitments.\nHelpers for conditional transactions.\nEthereum protocol-related constants\nReturns the cumulative gas used in the block after this …\nReturns the cumulative gas used at this receipt.\nReturns the cumulative gas used at this receipt.\nGas used\nDecodes the inner BlobTransactionSidecar fields from RLP …\nDecode all slices of data from the blobs.\nRetrieves the difficulty of the block\nA scalar value corresponding to the difficulty level of …\nEIP-2718 decode the signed transaction.\nEIP-2718 decode the signed transaction with a specified …\nEIP-2718 encode the signed transaction.\nEIP-2718 encodes the receipt with the provided bloom …\nEIP-2718 encode the signed transaction with a specified …\nGet the length of the transaction when EIP-2718 encoded.\nEIP-2718 encoded length with the provided bloom filter.\nReturns an iterator over all blob transactions of the …\nEncodes the inner BlobTransactionSidecar fields as RLP …\nChecks if the block’s timestamp is in the future based …\nChecks if the block’s timestamp is in the future based …\nRetrieves the excess blob gas of the block, if available\nA running total of blob gas consumed in excess of the …\nRetrieves the block’s extra data field\nAn arbitrary byte array containing data relevant to this …\nFinish the sidecar, and commit to the data. This method …\nNo-op\nReturns the argument unchanged.\nInstantiate a new builder with the provided coder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConsume the structure, returning only the receipt\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInstantiate a new builder with the provided coder and …\nCreate a new builder from a slice of data.\nCreate a new builder from a slice of data by calling …\nRetrieves the gas limit of the block\nA scalar value equal to the current limit of gas …\nRetrieves the gas used by the block\nA scalar value equal to the total gas used in transactions …\nReturns whether or not the block body contains any blob …\nReturns whether or not the block body contains any …\nGet the hash.\nReturns a reference to the transaction hash.\nGet the hash.\nCalculate the seal hash, this may be slow.\nHeavy function that will calculate hash of data and will …\nBlock header.\nIngest a slice of data into the builder.\nGet the inner item.\nGet the length of the inner receipt in the 2718 encoding.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>Block</code> from the body and its header.\nConsumes the block and returns the body.\nConsume the structure, returning the receipt and the bloom …\nConsumes the block and returns the header.\nUnseal the inner item, discarding the hash.\nDecompose into parts.\nSplits the transaction into parts.\nConsumes the type and converts it into <code>ReceiptWithBloom</code> …\nConsumes the type and converts it into <code>ReceiptWithBloom</code> …\nReturns true if the transaction was a post-[EIP-658] …\nCheck if the builder is empty.\nChecks if the header is considered empty - has no …\nChecks if the header is considered empty - has no …\nReturns <code>true</code> if the <code>Receipts</code> vector is empty.\nChecks if the nonce exists, and if it exists, if it’s …\nChecks if the nonce exists, and if it exists, if it’s …\nReturns true if the transaction was a pre-EIP-658 …\nReturn true if the transaction was successful.\nChecks if the block’s difficulty is set to zero, …\nChecks if the block’s difficulty is set to zero, …\nCalculate the length of bytes used by field elements in …\nReturns the length of the <code>Receipts</code> vector.\nReturns the logs emitted by this transaction.\nReturn the receipt logs.\nReturn the receipt logs.\nLog send from contracts.\nRetrieves the logs bloom filter of the block\nReturn the receipt’s bloom.\nThe Bloom filter composed from indexable information …\nThe bloom filter.\nConverts the block’s header type by applying a function …\nConverts the block’s transaction type by applying a …\nRetrieves the mix hash of the block, if available\nA 256-bit hash which, combined with the nonce, proves that …\nNetwork decode the signed transaction.\nNetwork decode the signed transaction with a specified …\nNetwork encode the signed transaction.\nNetwork encode the signed transaction with a specified …\nGet the length of the transaction when network encoded.\nInstantiate a new builder and new coder instance.\nConstructs a new BlobTransactionSidecar from a set of …\nCreate new ReceiptWithBloom\nSeal the inner item.\nSeal the inner item, by reference.\nSeal a reference to the inner item with some function.\nInstantiate without performing the hash. This should be …\nInstantiate from a transaction and signature. Does not …\nSeal the inner item with some function.\nCalculate base fee for next block according to the …\nCalculate base fee for next block according to the …\nCalculate base fee for next block according to the …\nReturns the blob fee for the next block according to the …\nReturns the blob fee for the next block according to the …\nReturns the blob fee for the next block according to the …\nCalculate excess blob gas for the next block according to …\nCalculate excess blob gas for the next block according to …\nCalculate excess blob gas for the next block according to …\nRetrieves the nonce of the block, if avaialble\nThe account’s nonce.\nThe account’s nonce.\nA 64-bit value which, combined with the mixhash, proves …\nReturns the block’s number and hash.\nReturns the block’s number and hash with the parent hash.\nRetrieves the block number\nA scalar value equal to the number of ancestor blocks. The …\nOmmers/uncles header.\nRetrieves the ommers hash of the block\nThe Keccak 256-bit hash of the ommers list portion of this …\nCheck if the ommers hash equals to empty hash list.\nRetrieves the parent beacon block root of the block, if …\nThe hash of the parent beacon block’s root is included …\nRetrieves the parent hash of the block\nThe Keccak 256-bit hash of the parent block’s header, in …\nReturns the parent block’s number and hash\nReturns the parent block’s number and hash\nReturns the parent block’s number and hash\nHelper function for calculating Merkle proofs and hashes.\nThe blob proofs.\nPush a new vector of receipts into the <code>Receipts</code> collection.\nThe receipt.\nA two-dimensional vector of <code>Receipt</code> instances.\nRetrieves the receipts root hash of the block\nThe Keccak 256-bit hash of the root node of the trie …\nRetrieves the requests hash of the block, if available\nThe Keccak 256-bit hash of the an RLP encoded list with …\nCalculate the number of field elements required to store …\nDecodes the BlobTransactionSidecar from RLP bytes.\nRLP decode the signed transaction.\nRLP-decodes receipt’s field with a <code>Bloom</code>.\nRLP decodes receipt and <code>Bloom</code> into <code>ReceiptWithBloom</code> …\nEncodes the BlobTransactionSidecar as RLP bytes.\nRLP encode the signed transaction.\nRLP-encodes receipt fields with the given <code>Bloom</code> without an …\nRLP encodes the receipt with the provided bloom filter.\nReturns length of RLP-encoded receipt fields with the …\nCalculates the length of the BlobTransactionSidecar when …\nGet the length of the transaction when RLP encoded.\nReturns the length of the receipt payload with the …\nReturns RLP header for this receipt encoding with the …\nCalculate the length of the rlp payload of the network …\nSeal the header with a known hash.\nGet the hash.\nSeal a borrowed object by calculating the hash. This may …\nInstantiate an unchecked seal. This should be used with …\nSeal the object by calculating the hash. This may be slow.\nInstantiate an unchecked seal. This should be used with …\nReturns a reference to the signature.\nCalculate the signing hash for the transaction.\nCalculates a size heuristic for the in-memory size of the …\nCalculate a heuristic for the in-memory size of the Header.\nDecompose into parts. Alias for <code>Self::into_parts</code>.\nRetrieves the state root hash of the block\nThe Keccak 256-bit hash of the root node of the state …\nReturns true if the transaction was successful OR if the …\nReturns the success status of the receipt’s transaction.\nIf transaction is executed successfully.\nReturns the status or post state of the transaction.\nThe hash of the storage account data.\nThe hash of the storage account data.\nReturns the transaction without signature.\nReturns a successful transaction status.\nTake the blobs from the builder, without committing them …\nRetrieves the timestamp of the block\nA scalar value equal to the reasonable output of Unix’s …\nTransaction types.\nCheck if the transaction root equals to empty root.\nReturns an iterator over all transactions.\nTransactions in this block.\nRetrieves the transactions root hash of the block\nThe Keccak 256-bit hash of the root node of the trie …\nCompute  hash as committed to in the MPT trie without …\nConverts the block’s header type by applying a fallible …\nConverts the block’s transaction type by applying a …\nReturns a reference to the transaction.\nReturns a mutable reference to the transaction.\nReturn the <code>TxType</code> of the inner receipt.\nCreates a new empty uncle block.\nUnseal the inner item, discarding the hash. Alias for …\nUtilities for working with EIP-4844 field elements and …\nReturns the versioned hash for the blob at the given …\nReturns an iterator over the versioned hashes of the …\nCalculates the bloom filter for the receipt and returns …\nReturns <code>ReceiptWithBloom</code> with the computed bloom filter …\nReturns <code>ReceiptWithBloom</code> with the computed bloom filter …\nCreate a new builder with a pre-allocated capacity. This …\nBlock withdrawals.\nRetrieves the withdrawals root hash of the block, if …\nThe Keccak 256-bit hash of the withdrawals list portion of …\nContains attributes of a block that are relevant for block …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>BlockConditionalAttributes</code> with the given …\nThe number of the block.\nThe block’s timestamp\nTestnet genesis hash.\nIdentifier for an EIP1559 transaction.\nIdentifier for an EIP2930 transaction.\nIdentifier for an EIP4844 transaction.\nIdentifier for an EIP7702 transaction.\nOmmer root of empty list.\nTransactions root of empty receipts set.\nRoot hash of an empty trie.\nTransactions root of empty transactions set.\nWithdrawals root of empty withdrawals set.\nMultiplier for converting ether to wei.\nMultiplier for converting finney (milliether) to wei.\nBase goerli genesis hash.\nGoerli genesis hash.\nOptimism goerli genesis hash.\nMultiplier for converting gwei to wei.\nHolesky genesis hash.\nKeccak256 over empty array.\nIdentifier for legacy transaction, however a legacy tx is …\nThe Ethereum mainnet genesis hash.\nMaximum extra data size in a block after genesis\nMultiplier for converting mgas to gas.\nThe first four bytes of the call data for a function call …\nSepolia genesis hash.\nCalculates the root hash for ommer/uncle headers.\nCalculates the receipt root.\nCalculate a transaction root.\nCalculates the root hash of the withdrawals.\nCompute a trie root of the collection of rlp encodable …\nCompute a trie root of the collection of items with a …\nCalculates the root hash of the state represented as MPT.\nHashes and sorts account keys, then proceeds to …\nHashes and sorts account keys, then proceeds to …\nSorts the hashed account keys and calculates the root hash …\nCalculates the root hash of account storage trie.\nHashes storage keys, sorts them and them calculates the …\nSorts and calculates the root hash of account storage trie.\nA Blob serialized as 0x-prefixed hex string\nThis represents a set of blobs, and its corresponding …\nA commitment/proof serialized as 0x-prefixed hex string\nEIP-1559 transaction type.\nA <code>TxEip1559</code> tagged with type 2.\nEIP-1559 transaction\nEIP-2930 transaction type.\nA <code>TxEip2930</code> tagged with type 1.\nEIP-2930 transaction\nEIP-4844 transaction type.\nA TxEip4844 tagged with type 3. An EIP-4844 transaction …\nEIP-4844 transaction\nEIP-7702 transaction type.\nA <code>TxEip7702</code> tagged with type 4.\nEIP-7702 transaction\nLegacy transaction type.\nAn untagged <code>TxLegacy</code>.\nLegacy transaction\nSigned transaction with recovered signer.\nBuild a <code>BlobTransactionSidecar</code> from an arbitrary amount of …\nA strategy for coding and decoding data into sidecars.\nA signable transaction.\nA type that can recover the signer of a transaction.\nSimple coder that only uses the last 31 bytes of each …\nThe EIP-2718 transaction type.\nRepresents a minimal EVM transaction.\nAdditional fields in the context of a (maybe) pending …\nAdditional fields in the context of a block that contains …\nA transaction with a priority fee (EIP-1559).\nTransaction with an <code>AccessList</code> (EIP-2930).\nA transaction with a priority fee (EIP-7702).\nThe Ethereum EIP-2718 Transaction Envelope.\nLegacy transaction.\nEthereum <code>TransactionType</code> flags as specified in EIPs 2718, …\nA trait that helps to determine the type of the …\nThe TypedTransaction enum represents all Ethereum …\nReturns the EIP-2930 <code>access_list</code> for the particular …\nThe accessList specifies a list of addresses and storage …\nThe accessList specifies a list of addresses and storage …\nThe accessList specifies a list of addresses and storage …\nReturns the <code>TxEip1559</code> variant if the transaction is an …\nReturns the <code>TxEip2930</code> variant if the transaction is an …\nReturns the <code>TxEip4844Variant</code> variant if the transaction is …\nReturns the <code>TxEip7702</code> variant if the transaction is an …\nReturns the <code>TxLegacy</code> variant if the transaction is a …\nReturns the <code>SignedAuthorization</code> list of the transaction.\nAuthorizations are used to temporarily set the code of its …\nBase fee of the block.\nBase fee of the block.\nReturns the total gas for all blobs in this transaction.\nBlob versioned hashes for eip4844 transaction. For …\nThe blob data.\nHash of the block.\nHash of the block.\nNumber of the block.\nNumber of the block.\nGet <code>chain_id</code>.\nEIP-155: Simple replay attack protection\nAdded as EIP-pub 155: Simple replay attack protection\nEIP-155: Simple replay attack protection\nAdded as EIP-155: Simple replay attack protection\nClone the inner transaction.\nCode a slice of data into the builder.\nThe blob commitments.\nDecode all slices of data from the blobs.\nReturns the effective gas price for the given base fee.\nReturns the effective tip for this transaction.\nReturn the inner EIP-1559 transaction if it exists.\nReturn the length of the inner txn, including type byte …\nReturn the inner EIP-2930 transaction if it exists.\n[EIP-4844] constants, helpers, and types.\nUtilities for working with EIP-4844 field elements and …\nReturn the inner EIP-7702 transaction if it exists.\nThis encodes the transaction <em>with</em> the signature, and an …\nRLP-encodes the transaction for signing.\nRLP-encodes the transaction for signing it. Used to …\nThe excess blob gas of the block.\nFinish the sidecar, and commit to the data. This method …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHelper for decoding EIP-155 <code>v</code> value into <code>y_parity</code> boolean …\nGet <code>gas_limit</code>.\nA scalar value equal to the maximum amount of gas that …\nA scalar value equal to the maximum amount of gas that …\nA scalar value equal to the maximum amount of gas that …\nA scalar value equal to the maximum amount of gas that …\nGet <code>gas_price</code>.\nA scalar value equal to the number of Wei to be paid per …\nA scalar value equal to the number of Wei to be paid per …\nHash of the transaction.\nIndex of the transaction in the block\nIndex of the transaction in the block\nGet <code>data</code>.\nInput has two uses depending if transaction is Create or …\nInput has two uses depending if transaction is Create or …\nInput has two uses depending if transaction is Create or …\nInput has two uses depending if transaction is Create or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDissolve Self to its component\nConvert to a signed transaction by adding a signature and …\nTransform back to the transaction.\nReturns true if the transaction is a contract creation. We …\nReturns <code>true</code> if the transaction supports dynamic fees.\nReturns true if the transaction is an EIP-1559 transaction.\nReturns true if the type is an EIP-1559 transaction.\nReturns true if the transaction is an EIP-2930 transaction.\nReturns true if the type is an EIP-2930 transaction.\nReturns true if the transaction is an EIP-4844 transaction.\nReturns true if the type is an EIP-4844 transaction.\nReturns true if the transaction is an EIP-7702 transaction.\nReturns true if the type is an EIP-7702 transaction.\nReturns true if the transaction is a legacy transaction.\nReturns true if the type is a legacy transaction.\nReturns true if the transaction is replay protected.\nReturns true if the type matches the given type.\nReturns the transaction kind.\nReturn the inner legacy transaction if it exists.\nApplies the given closure to the inner transactions.\nMax fee per blob gas for EIP-4844 transaction.\nReturns the EIP-1559 the maximum fee per gas the caller is …\nA scalar value equal to the maximum amount of gas that …\nA scalar value equal to the maximum amount of gas that …\nReturns the EIP-1559 Priority fee the caller is paying to …\nMax Priority fee that transaction is paying\nMax Priority fee that transaction is paying\nCreate <code>Recovered</code> from the given transaction and <code>Address</code> of …\nGet <code>nonce</code>.\nA scalar value equal to the number of transactions sent by …\nA scalar value equal to the number of transactions sent by …\nA scalar value equal to the number of transactions sent by …\nA scalar value equal to the number of transactions sent by …\nOutputs the length of the signature RLP encoding for the …\nDefines the exact transaction variant that are allowed to …\nReturn the max priority fee per gas if the transaction is …\nThe blob proofs.\nRecover signer from signature and hash.\nRecover signer from signature and hash <em>without ensuring </em>…\nCalculate the number of field elements required to store …\nSets <code>chain_id</code>.\nSet <code>chain_id</code> if it is not already set. Checks that the …\nReturn the reference to signature.\nCalculate the signing hash for the transaction.\nCalculate the signing hash for the transaction.\nHelper module for encoding signatures of transactions …\nSigner of transaction recovered from signature\nReference to the signer of transaction recovered from …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nThe block’s timestamp.\nGet the transaction’s address of the contract that will …\nThe 160-bit address of the message call’s recipient or, …\nThe 160-bit address of the message call’s recipient or, …\nThe 160-bit address of the message call’s recipient.\nThe 160-bit address of the message call’s recipient or, …\nHelper for encoding <code>y_parity</code> boolean and optional <code>chain_id</code> …\nReturns a reference to the transaction.\nReturn the hash of the inner Signed.\nHash of the transaction.\nGet the transaction type.\nGet the transaction type.\nReturn the <code>TxType</code> of the inner txn.\nReturn the <code>TxType</code> of the inner txn.\nReturns the EIP-2718 type flag.\nGet <code>value</code>.\nA scalar value equal to the number of Wei to be …\nA scalar value equal to the number of Wei to be …\nA scalar value equal to the number of Wei to be …\nA scalar value equal to the number of Wei to be …\nReturns a new <code>TransactionInfo</code> with the provided base fee.\nThis represents a set of blobs, and its corresponding …\nEIP-4844 Blob Transaction\nA standalone transaction with blob hashes and max blob fee.\nEIP-4844 Blob Transaction\nEIP-4844 Blob Transaction\nA transaction with a sidecar, which contains the blob …\nThe accessList specifies a list of addresses and storage …\nReturns the total gas for all blobs in this transaction.\nIt contains a vector of fixed size hash(32 bytes)\nThe blob data.\nAdded as EIP-pub 155: Simple replay attack protection\nThe blob commitments.\nReturns the argument unchanged.\nConsumes the TxEip4844WithSidecar and returns the inner …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a new TxEip4844WithSidecar from a TxEip4844 and …\nA scalar value equal to the maximum amount of gas that …\nInput has two uses depending if transaction is Create or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the TxEip4844WithSidecar and returns the inner …\nConsumes the TxEip4844WithSidecar and returns the inner …\nMax fee per data gas\nA scalar value equal to the maximum amount of gas that …\nMax Priority fee that transaction is paying\nA scalar value equal to the number of transactions sent by …\nThe blob proofs.\nGet access to the inner sidecar BlobTransactionSidecar.\nThe sidecar.\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nThe 160-bit address of the message call’s recipient.\nTries to unwrap the <code>TxEip4844WithSidecar</code> returns the …\nGet access to the inner tx TxEip4844.\nGet access to the inner tx TxEip4844.\nThe actual transaction.\nGet the transaction type.\nGet transaction type.\nGet the transaction type.\nA scalar value equal to the number of Wei to be …\nA wrapper for a slice of bytes that is a whole, valid …\nDetermine whether a slice of bytes can be contained in a …\nCalculate the number of field elements required to store …\nCalculate the number of field elements required to store …\nA <code>TxEip1559</code> tagged with type 2.\nA <code>TxEip2930</code> tagged with type 1.\nA EIP-4844 transaction, which includes the transaction, …\nA <code>TxEip7702</code> tagged with type 4.\nAn untagged <code>TxLegacy</code>.\nAll possible transactions that can be included in a …\nReturns the <code>TxEip1559</code> variant if the transaction is an …\nReturns the <code>TxEip2930</code> variant if the transaction is an …\nReturns the <code>TxEip4844</code> variant if the transaction is an …\nReturns the <code>TxEip4844WithSidecar</code> variant if the …\nReturns the <code>TxEip7702</code> variant if the transaction is an …\nReturns the <code>TxLegacy</code> variant if the transaction is a …\nDecodes an enveloped post EIP-4844 <code>PooledTransaction</code>.\nThis encodes the transaction <em>with</em> the signature, and an …\nThis encodes the transaction <em>without</em> the signature, and is …\nReturns the argument unchanged.\nReference to transaction hash. Used to identify …\nCalls <code>U::from(self)</code>.\nConverts the transaction into <code>TxEnvelope</code>.\nReturns the signature of the transaction.\nHeavy operation that return signature hash over rlp …\nAttempts to unwrap the transaction into an EIP-1559 …\nAttempts to unwrap the transaction into an EIP-2930 …\nAttempts to unwrap the transaction into an EIP-4844 …\nAttempts to unwrap the transaction into an EIP-7702 …\nAttempts to unwrap the transaction into a legacy …\nDeserializes signed transaction expecting <code>v</code> key for …\nSerializes signed transaction with <code>v</code> key for signature …\nA wrapper for a slice of bytes that is a whole, valid …\nDetermine whether a slice of bytes can be contained in a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalculate the number of field elements required to store …\nCalculate the number of field elements required to store …\nInstantiate a new <code>WholeFe</code> from a slice of bytes, if it is …")