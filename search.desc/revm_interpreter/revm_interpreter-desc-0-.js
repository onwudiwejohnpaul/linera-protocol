searchState.loadedDescShard("revm_interpreter", 0, "revm-interpreter\nResult of the account load from Journal state.\nInvalid <code>CALL</code> with value transfer in static context.\nIndicates a call or contract creation.\nExceeded maximum call depth.\nExecution should continue to the next one.\nLegacy create scheme of <code>CREATE</code>.\nCreate scheme of <code>CREATE2</code>.\nAddress collision during contract creation.\nExceeded contract size limit during creation.\nCreated contract starts with invalid bytes (<code>0xEF</code>).\nExceeded init code size limit (EIP-3860:  Limit and meter …\nRevert if <code>CREATE</code>/<code>CREATE2</code> starts with <code>0xEF00</code>.\nInternal CREATE/CREATE starts with 0xEF00\nCreate scheme.\nA dummy Host implementation.\nStack overflow in EOF subroutine function calls.\nLegacy contract is calling opcode that is enabled only in …\nEIP-7702 code load result that contains optional …\nAux data overflow, new aux data is larger than <code>u16</code> max …\nAux data is smaller then already present data size.\nFatal external error. Returned by database.\nFunction return frame. Needed information for returning …\nFunction Stack\nEVM context host.\nInternal instruction that signals call or create.\nInternal instruction that signals Interpreter should …\nInternal result that are not ex\nInvalid EVM Object Format (EOF) init code.\n<code>EXT*CALL</code> target address needs to be padded with 0s.\n<code>ExtDelegateCall</code> calling a non EOF contract.\nInternal to ExtDelegateCall\nAn undefined bytecode value encountered during execution.\nInvalid jump destination. Dynamic jumps points to invalid …\nOut of gas error encountered while calling an invalid …\nEIP-170: Contract code size limit\nEIP-3860: Limit and meter initcode\nThe memory limit of the EVM has been exceeded.\nOut of gas error encountered during memory expansion.\nNonce overflow.\nThe feature or opcode is not activated in this version of …\nUnknown or invalid opcode.\nInsufficient funds for transfer.\nOut of gas error.\nInvalid memory or storage offset.\nPayment amount overflow.\nError in precompiled contract execution.\nOut of gas error encountered during the execution of a …\nReturn from the current call.\nReturn a contract (used in contract creation).\n<code>RETURNCONTRACT</code> called outside init EOF code.\nRevert the transaction.\nRepresents the result of an <code>sstore</code> operation.\nSelf-destruct the current contract.\nResult of a selfdestruct action.\nAttempting to push a value onto a full stack.\nAttempting to pop a value from an empty stack.\nInvalid state modification in static call.\nState load information that contains the data and if the …\nEncountered a <code>STOP</code> opcode\nConverts a <code>U256</code> value to a <code>isize</code>, saturating to <code>isize::MAX</code> …\nConverts a <code>U256</code> value to a <code>u64</code>, saturating to <code>MAX</code> if the …\nConverts a <code>U256</code> value to a <code>usize</code>, failing the instruction …\nConverts a <code>U256</code> value to a <code>usize</code> and returns <code>ret</code>, failing …\nConverts a <code>U256</code> value to a <code>usize</code>, saturating to <code>MAX</code> if the …\nGet balance of <code>address</code> and if the account is cold.\nGet the block hash of the given block <code>number</code>.\nCheck if the <code>SPEC</code> is enabled, and fail the instruction if …\nClears the storage and logs of the dummy host.\nGet code of <code>address</code> and if the account is cold.\nGet code hash of <code>address</code> and if the account is cold.\nreturned data\nReturns a reference to the environment.\nReturns a mutable reference to the environment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEVM gas calculation utilities.\nRecords a <code>gas</code> cost and fails the instruction if it would …\nSame as <code>gas!</code>, but with <code>gas</code> as an option.\nThe index of the code container that this frame is …\nEVM opcode implementations.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDeconstructs the <code>Eip7702CodeLoad</code> by extracting data and …\nTrue if account is cold loaded.\nTrue if account has delegate code and delegated account is …\nIs account empty, if true account is not created.\nReturns whether the result is an error.\nReturns true if the EVM has experienced an exceptional halt\nReturns <code>true</code> if the new value is equal to the present …\nReturns <code>true</code> if the new value is zero.\nReturns whether the result is a success.\nReturns <code>true</code> if the original value is equal to the new …\nReturns <code>true</code> if the original value is equal to the present …\nReturns <code>true</code> if the original value is zero.\nReturns <code>true</code> if the present value is zero.\nReturns whether the result is a revert.\nReturns true if the transaction reverted.\nReturns true if the transaction returned successfully …\nIs account and delegate code are loaded\nLoad an account code.\nEmit a log owned by <code>address</code> with given <code>LogData</code>.\nMaps the data of the <code>StateLoad</code> to a new value.\nReturn new function frame.\nReturns new function stack.\nCreate a new dummy host with the given <code>Env</code>.\nReturns a new <code>StateLoad</code> with the given data and cold load …\nReturns a new <code>Eip7702CodeLoad</code> with the given data and …\nReturns a new <code>Eip7702CodeLoad</code> with the given data and …\nReturns a new <code>Eip7702CodeLoad</code> with the given data and …\nNew value that is set\nEVM opcode definitions and utilities.\nValue of the storage when it is first read\nThe program counter where frame execution should continue.\nPops a frame from the stack and sets current_code_idx to …\nPops <code>U256</code> values from the stack. Fails the instruction if …\nPops <code>Address</code> values from the stack. Fails the instruction …\nPop <code>Address</code> values from the stack, returns <code>ret</code> on stack …\nPops <code>U256</code> values from the stack, and returns <code>ret</code>. Fails …\nPops <code>U256</code> values from the stack, and returns a reference …\nCurrent value of the storage\nPushes a new frame to the stack. and sets current_code_idx …\nPushes a <code>B256</code> value onto the stack. Fails the instruction …\nPushes <code>B256</code> values onto the stack. Fails the instruction …\nRecords a <code>gas</code> refund.\nError if the current call is executing EOF.\nError if not init eof call.\nFails the instruction if the current call is static.\nResizes the interpreter memory if necessary. Fails the …\nReturn stack length\nMark <code>address</code> to be deleted, with funds transferred to …\nSets current_code_idx, this is needed for JUMPF opcode.\nSets the delegation cold load status.\nGet storage value of <code>address</code> at <code>index</code> and if the account …\nSet storage value of account address at index.\nreturned data\nGet the transient storage value of <code>address</code> at <code>index</code>.\nReturns the HaltReason value the EVM has experienced an …\nReturns the SuccessReason value if this a successful result\nSet the transient storage value of <code>address</code> at <code>index</code>.\nSalt.\nRepresents the state of gas during execution.\nEIP-3860 : Limit and meter initcode\nEIP-1884: Repricing for trie-size-dependent opcodes\nInit and floor gas from transaction\nThe cost of a non-zero byte in calldata.\nThe cost of a non-zero byte in calldata adjusted by …\nThe multiplier for a non zero byte in calldata.\nThe multiplier for a non zero byte in calldata adjusted by …\nThe standard cost of calldata token.\nCalculate the transaction cost floor as specified in …\nInitial gas that is deducted for transaction to be …\nCalculate call gas cost for the call instruction.\nCalculate the cost of buffer per word.\n<code>CREATE2</code> opcode cost calculation.\nErases a gas cost from the totals.\n<code>EXP</code> opcode cost calculation.\n<code>EXTCODECOPY</code> opcode cost calculation.\nIf transaction is a Call and Prague is enabled floor_gas …\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the total number of tokens in calldata.\nEIP-3860: Limit and meter initcode\nInitial gas for transaction.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>KECCAK256</code> opcode cost calculation.\nReturns the gas limit.\n<code>LOG</code> opcode cost calculation.\nMemory expansion cost calculation for a given number of …\nMemory expansion cost calculation for a given memory …\nCreates a new <code>Gas</code> struct with the given gas limit.\nCreates a new <code>Gas</code> struct with the given gas limit, but …\nRecords an explicit cost.\nRecords a refund value.\nReturns the total amount of gas that was refunded.\nReturns the amount of gas remaining.\nReturn remaining gas after subtracting 63/64 parts.\n<code>SELFDESTRUCT</code> opcode cost calculation.\nSet a refund value for final refund.\nSet a refund value. This overrides the current refund …\nSet a spent value. This overrides the current spent value.\n<code>SLOAD</code> opcode cost calculation.\nSpends all remaining gas.\nReturns the total amount of gas spent.\nReturns the total amount of gas spent, minus the refunded …\n<code>SSTORE</code> opcode cost calculation.\n<code>SSTORE</code> opcode refund calculation.\n<code>*COPY</code> opcodes cost calculation.\nBerlin warm and cold storage access cost for account …\nBerlin warm and cold storage access cost for account …\nUtility macros to help implementing opcode instruction …\nImplements the <code>SIGNEXTEND</code> opcode as defined in the …\nEIP-145: Bitwise shifting instructions in EVM\nEIP-145: Bitwise shifting instructions in EVM\nEIP-145: Bitwise shifting instructions in EVM\nEOF Create instruction\nPop target address from stack and check if it is valid.\nResize memory and return range of memory. If <code>len</code> is 0 dont …\nInvalid opcode. This opcode halts the execution.\nEIP-140: REVERT instruction\nStop opcode. This opcode halts the execution.\nUnknown opcode. This opcode halts the execution.\nEIP-1052: EXTCODEHASH opcode\nEIP-1884: Repricing for trie-size-dependent opcodes\nEIP-1153: Transient storage opcodes Load value from …\nEIP-1153: Transient storage opcodes Store value to …\nEIP-3198: BASEFEE opcode\nEIP-7516: BLOBBASEFEE opcode\nEIP-1344: ChainID opcode\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEIP-3855: PUSH0 instruction\nEIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY\nPart of EOF <code>&lt;https://eips.ethereum.org/EIPS/eip-7069&gt;</code>.\nEIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY\nEVM contract information.\nEmpty shared memory.\nEVM bytecode interpreter.\nThe result of an interpreter operation.\nEVM interpreter stack limit.\nA sequential memory shared between calls, which uses a <code>Vec</code> …\nEVM stack with STACK_LIMIT capacity of words.\nBytecode contains contract code, size of original code, …\nCurrently run Bytecode that instruction result will point …\nAddress of the account the bytecode was loaded from. This …\nValue send to contract from transaction or from CALL …\nCaller of the EVM.\nReturns a reference to the memory of the current context, …\nReturns a mutable reference to the memory of the current …\nReturns a reference to the contract.\nContract information and invoking data\nCopies elements from one part of the memory to another …\nReturns the gas cost for the current memory expansion.\nReturns the opcode at the current instruction pointer.\nReturns a reference to the underlying data buffer.\nReturns a mutable reference to the underlying data buffer.\nDuplicates the <code>N</code>th value from the top of the stack.\nExchange two values on the stack.\nPrepares the shared memory for returning to the previous …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEOF function stack.\nReturns a reference to the interpreter’s gas state.\nThe gas state.\nThe gas usage information.\nReturns the byte at the given offset.\nReturns a U256 of the memory region at the given offset.\nReturns a 32-byte slice of the memory region at the given …\nBytecode hash for legacy. For EOF this would be None.\nContracts data\nInserts the outcome of a call into the virtual machine’s …\nInserts the output of a <code>create</code> call into the interpreter.\nThe current instruction pointer.\nThe execution control flag. If this is not set to <code>Continue</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the stack and returns the underlying data buffer.\nReturns <code>true</code> if the current memory range is empty.\nReturns whether the stack is empty.\nWhether we are Interpreting the Ethereum Object Format …\nIs init flag for eof create\nReturns whether the instruction result is an error.\nReturns whether the instruction result is a success.\nReturns whether the instruction result is a revert.\nWhether the interpreter is in “staticcall” mode, …\nReturns whether the given position is a valid jump …\nReturns the length of the current memory range.\nReturns the length of the stack in words.\nInstantiates a new contract by analyzing the given …\nCreates a new memory instance that can be shared between …\nInstantiate a new stack with the default stack limit.\nCreate new interpreter\nReturns a new <code>InterpreterResult</code> with the given values.\nPrepares the shared memory for a new context.\nCreates a new contract from the given <code>Env</code>.\nCreates a new contract from the given inputs.\nActions that the EVM should do.\nReturns number of words what would fit to provided number …\nThe output of the instruction execution.\nPeek a value at given index for the stack, where the top of\nRemoves the topmost element from the stack and returns it, …\nPops 2 values from the stack and returns them, in addition …\nPops 2 values from the stack.\nPops 3 values from the stack.\nPops 4 values from the stack.\nPops 5 values from the stack.\nPop the topmost value, returning the value and the new …\nRemoves the topmost element from the stack and returns it.\nReturns the current program counter.\nPush a new value onto the stack.\nPush a new value into the stack. If it will exceed the …\nPushes an arbitrary length slice of bytes onto the stack, …\nResizes the memory in-place so that <code>len</code> is equal to <code>new_len</code>…\nResize the memory to the new size. Returns whether the gas …\nResize the memory to the new size. Returns whether the gas …\nThe result of the instruction execution.\nThe return data buffer for internal calls. It has multi …\nExecutes the interpreter until it returns or stops.\nSet memory region at given <code>offset</code>.\nSet a value at given index for the stack, where the top of …\nSets the <code>byte</code> at the given <code>index</code>.\nSet memory from data. Our memory offset+len is expected to …\nSet is_eof_init to true, this is used to enable …\nSets the given U256 <code>value</code> to the memory region at the …\nSets the given 32-byte <code>value</code> to the memory region at the …\nShared memory.\nReturns a byte slice of the memory region at the given …\nReturns a byte slice of the memory region at the given …\nReturns a byte slice of the memory region at the given …\nReturns a reference to the interpreter’s stack.\nStack.\nReturns a mutable reference to the interpreter’s stack.\nSwaps the topmost value with the <code>N</code>th value from the top.\nTake memory and replace it with empty memory.\nTarget address of the account. Storage of this address is …\nPeeks the top of the stack.\nCreates a new memory instance that can be shared between …\nBackward jump should have same smallest and biggest stack …\nBackward jump should have same smallest and biggest stack …\nInvalid jump into immediate bytes.\nCALLF to non returning function is not allowed.\nCode section not accessed.\nCALLF section out of bounds.\nTypes of code sections. It is a error if container to …\nDATA load out of bounds.\nData size needs to be filled for ReturnContract type.\nEOFCREATE points to container out of bounds.\nEOF Error.\nEvery instruction inside bytecode should be forward …\nFirst types section is invalid. It should have inputs 0 …\nTypes section invalid\nJUMPF needs to have enough outputs.\nJUMPF Stack\nJump to out of bounds.\nInvalid jump into immediate bytes.\nJump out of bounds.\nJump with zero offset would make a jump to next opcode, it …\nLast instruction should be terminating.\nMax stack element mismatch.\nBytecode is too small and is missing immediate bytes for …\nSimilar to <code>EofValidationError::MissingImmediateBytes</code> but …\nNo code sections present\nSection is marked as non-returning but has either RETF or …\nOpcode is disabled in EOF. For example JUMP, JUMPI, etc.\nRETF biggest stack num more then outputs.\nMaxIndex in RJUMPV can’t be zero. Zero max index makes …\nReturn contract code.\nReturn or Stop opcodes.\nCALLF stack overflow.\nStack requirement is more than smallest stack items.\nSub container called in two different modes. Check <code>CodeType</code>…\nSub container not accessed.\nSmallest stack items is more than types output.\nOpcode is not known. It is not defined in the opcode table.\nMark code as accessed.\nVector of accessed codes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true of the code is initcode.\nReturns a new instance of <code>CodeSubContainerAccess</code>.\nStack of codes section that needs to be processed.\nCode accessed by subcontainer and expected subcontainer …\nThis code type\nPerform bytecode analysis.\nFully validates an <code>Eof</code> container.\nValidates that:\nValidates an <code>Eof</code> structure, without recursing into …\nDecodes <code>raw</code> into an <code>Eof</code> container and validates it.\nDecodes <code>raw</code> into an <code>Eof</code> container and validates it.\nApparent value, that is <strong>not</strong> actually transferred.\n<code>CALL</code>.\nCALL, CALLCODE, DELEGATECALL, STATICCALL or EOF EXT …\n<code>CALLCODE</code>\nInputs for a call.\nRepresents the outcome of a call operation in a virtual …\nCall scheme.\nCall value.\nLegacy create scheme of <code>CREATE</code>.\nCREATE or CREATE2 instruction called.\nCreate scheme of <code>CREATE2</code>.\nInputs for a create call.\nRepresents the outcome of a create operation in an …\nCreate scheme.\n<code>DELEGATECALL</code>\nEOF CREATE instruction called.\nInputs for EOF create call.\nEOF create can be called from two places:\n<code>EXTCALL</code>\n<code>EXTDELEGATECALL</code>\n<code>EXTSTATICCALL</code>\nNo action\nInterpreter finished execution.\n<code>STATICCALL</code>\nConcrete value, transferred from caller to callee at the …\nReturns the apparent value, if any.\nReturns the <strong>apparent</strong> call value.\nThe account address of bytecode that is going to be …\nReturns the call value, regardless of the transfer value …\nThis caller is invoking the call.\nCaller address of the EVM.\nCaller of Eof Craate\nReturns the address that this create call will create.\nReturns created address\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the gas usage information.\nRetrieves a reference to the <code>Gas</code> details from the …\nThe gas limit of the call.\nThe gas limit of the call.\nGas limit for the create call.\nReturns the call value, regardless of the type.\nThe init code of the contract.\nThe call data of the call.\nReturns a reference to the instruction result.\nRetrieves a reference to the <code>InstructionResult</code> from the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns result if action is return.\nReturns whether the call value is apparent, and not …\nReturns true if action is call.\nReturns true if action is create.\nWhether the call is initiated from EOF bytecode.\nReturns true if it is EOF EXT*CALL.\nReturns true if it is ExtDelegateCall.\nReturns true if action is none.\nReturns true if action is return.\nReturns true if action is some.\nWhether the call is a static call, or is initiated inside …\nReturns whether the call value will be transferred.\nEOF Create kind\nReturns the length of the memory range.\nReturns the start position of the memory offset.\nCreates new call inputs.\nConstructs a new <code>CallOutcome</code>.\nCreates new create inputs.\nConstructs a new <code>CreateOutcome</code>.\nCreate new EOF crate input from transaction that has …\nCreates new boxed call inputs.\nReturns boxed create inputs.\nReturns a new instance of EOFCreateInput.\nCreates new EOFCreateInputs from transaction.\nReturns a reference to the output data.\nRetrieves a reference to the output bytes from the …\nThe return memory offset where the output of the call is …\nThe call scheme.\nThe create scheme.\nTarget address, this account storage is going to be …\nReturns the transferred value, if any.\nReturns the address of the transfer source account.\nReturns the address of the transfer target account.\nReturns the transfer value.\nReturns <code>true</code> if the call will transfer a non-zero value.\nCall value.\nThe value to transfer.\nValues of ether transferred\nSalt.\nThe <code>0x01</code> (“ADD”) opcode.\nThe <code>0x01</code> (“ADD”) opcode.\nThe <code>0x08</code> (“ADDMOD”) opcode.\nThe <code>0x08</code> (“ADDMOD”) opcode.\nThe <code>0x30</code> (“ADDRESS”) opcode.\nThe <code>0x30</code> (“ADDRESS”) opcode.\nThe <code>0x16</code> (“AND”) opcode.\nThe <code>0x16</code> (“AND”) opcode.\nThe <code>0x31</code> (“BALANCE”) opcode.\nThe <code>0x31</code> (“BALANCE”) opcode.\nThe <code>0x48</code> (“BASEFEE”) opcode.\nThe <code>0x48</code> (“BASEFEE”) opcode.\nThe <code>0x4A</code> (“BLOBBASEFEE”) opcode.\nThe <code>0x4A</code> (“BLOBBASEFEE”) opcode.\nThe <code>0x49</code> (“BLOBHASH”) opcode.\nThe <code>0x49</code> (“BLOBHASH”) opcode.\nThe <code>0x40</code> (“BLOCKHASH”) opcode.\nThe <code>0x40</code> (“BLOCKHASH”) opcode.\nThe <code>0x1A</code> (“BYTE”) opcode.\nThe <code>0x1A</code> (“BYTE”) opcode.\nEVM boxed dynamic opcode function signature.\nA table of boxed instructions.\nThe <code>0xF1</code> (“CALL”) opcode.\nThe <code>0xF1</code> (“CALL”) opcode.\nThe <code>0xF2</code> (“CALLCODE”) opcode.\nThe <code>0xF2</code> (“CALLCODE”) opcode.\nThe <code>0x37</code> (“CALLDATACOPY”) opcode.\nThe <code>0x37</code> (“CALLDATACOPY”) opcode.\nThe <code>0x35</code> (“CALLDATALOAD”) opcode.\nThe <code>0x35</code> (“CALLDATALOAD”) opcode.\nThe <code>0x36</code> (“CALLDATASIZE”) opcode.\nThe <code>0x36</code> (“CALLDATASIZE”) opcode.\nThe <code>0x33</code> (“CALLER”) opcode.\nThe <code>0x33</code> (“CALLER”) opcode.\nThe <code>0xE3</code> (“CALLF”) opcode.\nThe <code>0xE3</code> (“CALLF”) opcode.\nThe <code>0x34</code> (“CALLVALUE”) opcode.\nThe <code>0x34</code> (“CALLVALUE”) opcode.\nThe <code>0x46</code> (“CHAINID”) opcode.\nThe <code>0x46</code> (“CHAINID”) opcode.\nThe <code>0x39</code> (“CODECOPY”) opcode.\nThe <code>0x39</code> (“CODECOPY”) opcode.\nThe <code>0x38</code> (“CODESIZE”) opcode.\nThe <code>0x38</code> (“CODESIZE”) opcode.\nThe <code>0x41</code> (“COINBASE”) opcode.\nThe <code>0x41</code> (“COINBASE”) opcode.\nThe <code>0xF0</code> (“CREATE”) opcode.\nThe <code>0xF0</code> (“CREATE”) opcode.\nThe <code>0xF5</code> (“CREATE2”) opcode.\nThe <code>0xF5</code> (“CREATE2”) opcode.\nThe <code>0xD3</code> (“DATACOPY”) opcode.\nThe <code>0xD3</code> (“DATACOPY”) opcode.\nThe <code>0xD0</code> (“DATALOAD”) opcode.\nThe <code>0xD0</code> (“DATALOAD”) opcode.\nThe <code>0xD1</code> (“DATALOADN”) opcode.\nThe <code>0xD1</code> (“DATALOADN”) opcode.\nThe <code>0xD2</code> (“DATASIZE”) opcode.\nThe <code>0xD2</code> (“DATASIZE”) opcode.\nThe <code>0xF4</code> (“DELEGATECALL”) opcode.\nThe <code>0xF4</code> (“DELEGATECALL”) opcode.\nThe <code>0x44</code> (“DIFFICULTY”) opcode.\nThe <code>0x44</code> (“DIFFICULTY”) opcode.\nThe <code>0x04</code> (“DIV”) opcode.\nThe <code>0x04</code> (“DIV”) opcode.\nThe <code>0x80</code> (“DUP1”) opcode.\nThe <code>0x80</code> (“DUP1”) opcode.\nThe <code>0x89</code> (“DUP10”) opcode.\nThe <code>0x89</code> (“DUP10”) opcode.\nThe <code>0x8A</code> (“DUP11”) opcode.\nThe <code>0x8A</code> (“DUP11”) opcode.\nThe <code>0x8B</code> (“DUP12”) opcode.\nThe <code>0x8B</code> (“DUP12”) opcode.\nThe <code>0x8C</code> (“DUP13”) opcode.\nThe <code>0x8C</code> (“DUP13”) opcode.\nThe <code>0x8D</code> (“DUP14”) opcode.\nThe <code>0x8D</code> (“DUP14”) opcode.\nThe <code>0x8E</code> (“DUP15”) opcode.\nThe <code>0x8E</code> (“DUP15”) opcode.\nThe <code>0x8F</code> (“DUP16”) opcode.\nThe <code>0x8F</code> (“DUP16”) opcode.\nThe <code>0x81</code> (“DUP2”) opcode.\nThe <code>0x81</code> (“DUP2”) opcode.\nThe <code>0x82</code> (“DUP3”) opcode.\nThe <code>0x82</code> (“DUP3”) opcode.\nThe <code>0x83</code> (“DUP4”) opcode.\nThe <code>0x83</code> (“DUP4”) opcode.\nThe <code>0x84</code> (“DUP5”) opcode.\nThe <code>0x84</code> (“DUP5”) opcode.\nThe <code>0x85</code> (“DUP6”) opcode.\nThe <code>0x85</code> (“DUP6”) opcode.\nThe <code>0x86</code> (“DUP7”) opcode.\nThe <code>0x86</code> (“DUP7”) opcode.\nThe <code>0x87</code> (“DUP8”) opcode.\nThe <code>0x87</code> (“DUP8”) opcode.\nThe <code>0x88</code> (“DUP9”) opcode.\nThe <code>0x88</code> (“DUP9”) opcode.\nThe <code>0xE6</code> (“DUPN”) opcode.\nThe <code>0xE6</code> (“DUPN”) opcode.\nEVM dynamic opcode function signature.\nThe <code>0xEC</code> (“EOFCREATE”) opcode.\nThe <code>0xEC</code> (“EOFCREATE”) opcode.\nThe <code>0x14</code> (“EQ”) opcode.\nThe <code>0x14</code> (“EQ”) opcode.\nThe <code>0xE8</code> (“EXCHANGE”) opcode.\nThe <code>0xE8</code> (“EXCHANGE”) opcode.\nThe <code>0x0A</code> (“EXP”) opcode.\nThe <code>0x0A</code> (“EXP”) opcode.\nThe <code>0xF8</code> (“EXTCALL”) opcode.\nThe <code>0xF8</code> (“EXTCALL”) opcode.\nThe <code>0x3C</code> (“EXTCODECOPY”) opcode.\nThe <code>0x3C</code> (“EXTCODECOPY”) opcode.\nThe <code>0x3F</code> (“EXTCODEHASH”) opcode.\nThe <code>0x3F</code> (“EXTCODEHASH”) opcode.\nThe <code>0x3B</code> (“EXTCODESIZE”) opcode.\nThe <code>0x3B</code> (“EXTCODESIZE”) opcode.\nThe <code>0xF9</code> (“EXTDELEGATECALL”) opcode.\nThe <code>0xF9</code> (“EXTDELEGATECALL”) opcode.\nThe <code>0xFB</code> (“EXTSTATICCALL”) opcode.\nThe <code>0xFB</code> (“EXTSTATICCALL”) opcode.\nThe <code>0x5A</code> (“GAS”) opcode.\nThe <code>0x5A</code> (“GAS”) opcode.\nThe <code>0x45</code> (“GASLIMIT”) opcode.\nThe <code>0x45</code> (“GASLIMIT”) opcode.\nThe <code>0x3A</code> (“GASPRICE”) opcode.\nThe <code>0x3A</code> (“GASPRICE”) opcode.\nThe <code>0x11</code> (“GT”) opcode.\nThe <code>0x11</code> (“GT”) opcode.\nThe <code>0xFE</code> (“INVALID”) opcode.\nThe <code>0xFE</code> (“INVALID”) opcode.\nThe <code>0x15</code> (“ISZERO”) opcode.\nThe <code>0x15</code> (“ISZERO”) opcode.\nEVM opcode function signature.\nInstruction table is list of instruction function pointers …\nEither a plain, static instruction table, or a boxed, …\nThe <code>0x56</code> (“JUMP”) opcode.\nThe <code>0x56</code> (“JUMP”) opcode.\nThe <code>0x5B</code> (“JUMPDEST”) opcode.\nThe <code>0x5B</code> (“JUMPDEST”) opcode.\nThe <code>0xE5</code> (“JUMPF”) opcode.\nThe <code>0xE5</code> (“JUMPF”) opcode.\nThe <code>0x57</code> (“JUMPI”) opcode.\nThe <code>0x57</code> (“JUMPI”) opcode.\nThe <code>0x20</code> (“KECCAK256”) opcode.\nThe <code>0x20</code> (“KECCAK256”) opcode.\nThe <code>0xA0</code> (“LOG0”) opcode.\nThe <code>0xA0</code> (“LOG0”) opcode.\nThe <code>0xA1</code> (“LOG1”) opcode.\nThe <code>0xA1</code> (“LOG1”) opcode.\nThe <code>0xA2</code> (“LOG2”) opcode.\nThe <code>0xA2</code> (“LOG2”) opcode.\nThe <code>0xA3</code> (“LOG3”) opcode.\nThe <code>0xA3</code> (“LOG3”) opcode.\nThe <code>0xA4</code> (“LOG4”) opcode.\nThe <code>0xA4</code> (“LOG4”) opcode.\nThe <code>0x10</code> (“LT”) opcode.\nThe <code>0x10</code> (“LT”) opcode.\nThe <code>0x5E</code> (“MCOPY”) opcode.\nThe <code>0x5E</code> (“MCOPY”) opcode.\nThe <code>0x51</code> (“MLOAD”) opcode.\nThe <code>0x51</code> (“MLOAD”) opcode.\nThe <code>0x06</code> (“MOD”) opcode.\nThe <code>0x06</code> (“MOD”) opcode.\nThe <code>0x59</code> (“MSIZE”) opcode.\nThe <code>0x59</code> (“MSIZE”) opcode.\nThe <code>0x52</code> (“MSTORE”) opcode.\nThe <code>0x52</code> (“MSTORE”) opcode.\nThe <code>0x53</code> (“MSTORE8”) opcode.\nThe <code>0x53</code> (“MSTORE8”) opcode.\nThe <code>0x02</code> (“MUL”) opcode.\nThe <code>0x02</code> (“MUL”) opcode.\nThe <code>0x09</code> (“MULMOD”) opcode.\nThe <code>0x09</code> (“MULMOD”) opcode.\nAlias for the <code>JUMPDEST</code> opcode.\nThe <code>0x19</code> (“NOT”) opcode.\nThe <code>0x19</code> (“NOT”) opcode.\nThe <code>0x43</code> (“NUMBER”) opcode.\nThe <code>0x43</code> (“NUMBER”) opcode.\nMaps each opcode to its info.\nThe <code>0x17</code> (“OR”) opcode.\nThe <code>0x17</code> (“OR”) opcode.\nThe <code>0x32</code> (“ORIGIN”) opcode.\nThe <code>0x32</code> (“ORIGIN”) opcode.\nAn EVM opcode.\nAn error indicating that an opcode is invalid.\nInformation about opcode, such as name, and stack inputs …\nThe <code>0x58</code> (“PC”) opcode.\nThe <code>0x58</code> (“PC”) opcode.\nThe <code>0x50</code> (“POP”) opcode.\nThe <code>0x50</code> (“POP”) opcode.\nThe <code>0x5F</code> (“PUSH0”) opcode.\nThe <code>0x5F</code> (“PUSH0”) opcode.\nThe <code>0x60</code> (“PUSH1”) opcode.\nThe <code>0x60</code> (“PUSH1”) opcode.\nThe <code>0x69</code> (“PUSH10”) opcode.\nThe <code>0x69</code> (“PUSH10”) opcode.\nThe <code>0x6A</code> (“PUSH11”) opcode.\nThe <code>0x6A</code> (“PUSH11”) opcode.\nThe <code>0x6B</code> (“PUSH12”) opcode.\nThe <code>0x6B</code> (“PUSH12”) opcode.\nThe <code>0x6C</code> (“PUSH13”) opcode.\nThe <code>0x6C</code> (“PUSH13”) opcode.\nThe <code>0x6D</code> (“PUSH14”) opcode.\nThe <code>0x6D</code> (“PUSH14”) opcode.\nThe <code>0x6E</code> (“PUSH15”) opcode.\nThe <code>0x6E</code> (“PUSH15”) opcode.\nThe <code>0x6F</code> (“PUSH16”) opcode.\nThe <code>0x6F</code> (“PUSH16”) opcode.\nThe <code>0x70</code> (“PUSH17”) opcode.\nThe <code>0x70</code> (“PUSH17”) opcode.\nThe <code>0x71</code> (“PUSH18”) opcode.\nThe <code>0x71</code> (“PUSH18”) opcode.\nThe <code>0x72</code> (“PUSH19”) opcode.\nThe <code>0x72</code> (“PUSH19”) opcode.\nThe <code>0x61</code> (“PUSH2”) opcode.\nThe <code>0x61</code> (“PUSH2”) opcode.\nThe <code>0x73</code> (“PUSH20”) opcode.\nThe <code>0x73</code> (“PUSH20”) opcode.\nThe <code>0x74</code> (“PUSH21”) opcode.\nThe <code>0x74</code> (“PUSH21”) opcode.\nThe <code>0x75</code> (“PUSH22”) opcode.\nThe <code>0x75</code> (“PUSH22”) opcode.\nThe <code>0x76</code> (“PUSH23”) opcode.\nThe <code>0x76</code> (“PUSH23”) opcode.\nThe <code>0x77</code> (“PUSH24”) opcode.\nThe <code>0x77</code> (“PUSH24”) opcode.\nThe <code>0x78</code> (“PUSH25”) opcode.\nThe <code>0x78</code> (“PUSH25”) opcode.\nThe <code>0x79</code> (“PUSH26”) opcode.\nThe <code>0x79</code> (“PUSH26”) opcode.\nThe <code>0x7A</code> (“PUSH27”) opcode.\nThe <code>0x7A</code> (“PUSH27”) opcode.\nThe <code>0x7B</code> (“PUSH28”) opcode.\nThe <code>0x7B</code> (“PUSH28”) opcode.\nThe <code>0x7C</code> (“PUSH29”) opcode.\nThe <code>0x7C</code> (“PUSH29”) opcode.\nThe <code>0x62</code> (“PUSH3”) opcode.\nThe <code>0x62</code> (“PUSH3”) opcode.\nThe <code>0x7D</code> (“PUSH30”) opcode.\nThe <code>0x7D</code> (“PUSH30”) opcode.\nThe <code>0x7E</code> (“PUSH31”) opcode.\nThe <code>0x7E</code> (“PUSH31”) opcode.\nThe <code>0x7F</code> (“PUSH32”) opcode.\nThe <code>0x7F</code> (“PUSH32”) opcode.\nThe <code>0x63</code> (“PUSH4”) opcode.\nThe <code>0x63</code> (“PUSH4”) opcode.\nThe <code>0x64</code> (“PUSH5”) opcode.\nThe <code>0x64</code> (“PUSH5”) opcode.\nThe <code>0x65</code> (“PUSH6”) opcode.\nThe <code>0x65</code> (“PUSH6”) opcode.\nThe <code>0x66</code> (“PUSH7”) opcode.\nThe <code>0x66</code> (“PUSH7”) opcode.\nThe <code>0x67</code> (“PUSH8”) opcode.\nThe <code>0x67</code> (“PUSH8”) opcode.\nThe <code>0x68</code> (“PUSH9”) opcode.\nThe <code>0x68</code> (“PUSH9”) opcode.\nThe <code>0xE4</code> (“RETF”) opcode.\nThe <code>0xE4</code> (“RETF”) opcode.\nThe <code>0xF3</code> (“RETURN”) opcode.\nThe <code>0xF3</code> (“RETURN”) opcode.\nThe <code>0xEE</code> (“RETURNCONTRACT”) opcode.\nThe <code>0xEE</code> (“RETURNCONTRACT”) opcode.\nThe <code>0x3E</code> (“RETURNDATACOPY”) opcode.\nThe <code>0x3E</code> (“RETURNDATACOPY”) opcode.\nThe <code>0xF7</code> (“RETURNDATALOAD”) opcode.\nThe <code>0xF7</code> (“RETURNDATALOAD”) opcode.\nThe <code>0x3D</code> (“RETURNDATASIZE”) opcode.\nThe <code>0x3D</code> (“RETURNDATASIZE”) opcode.\nThe <code>0xFD</code> (“REVERT”) opcode.\nThe <code>0xFD</code> (“REVERT”) opcode.\nThe <code>0xE0</code> (“RJUMP”) opcode.\nThe <code>0xE0</code> (“RJUMP”) opcode.\nThe <code>0xE1</code> (“RJUMPI”) opcode.\nThe <code>0xE1</code> (“RJUMPI”) opcode.\nThe <code>0xE2</code> (“RJUMPV”) opcode.\nThe <code>0xE2</code> (“RJUMPV”) opcode.\nThe <code>0x1D</code> (“SAR”) opcode.\nThe <code>0x1D</code> (“SAR”) opcode.\nThe <code>0x05</code> (“SDIV”) opcode.\nThe <code>0x05</code> (“SDIV”) opcode.\nThe <code>0x47</code> (“SELFBALANCE”) opcode.\nThe <code>0x47</code> (“SELFBALANCE”) opcode.\nThe <code>0xFF</code> (“SELFDESTRUCT”) opcode.\nThe <code>0xFF</code> (“SELFDESTRUCT”) opcode.\nThe <code>0x13</code> (“SGT”) opcode.\nThe <code>0x13</code> (“SGT”) opcode.\nThe <code>0x1B</code> (“SHL”) opcode.\nThe <code>0x1B</code> (“SHL”) opcode.\nThe <code>0x1C</code> (“SHR”) opcode.\nThe <code>0x1C</code> (“SHR”) opcode.\nThe <code>0x0B</code> (“SIGNEXTEND”) opcode.\nThe <code>0x0B</code> (“SIGNEXTEND”) opcode.\nThe <code>0x54</code> (“SLOAD”) opcode.\nThe <code>0x54</code> (“SLOAD”) opcode.\nThe <code>0x12</code> (“SLT”) opcode.\nThe <code>0x12</code> (“SLT”) opcode.\nThe <code>0x07</code> (“SMOD”) opcode.\nThe <code>0x07</code> (“SMOD”) opcode.\nThe <code>0x55</code> (“SSTORE”) opcode.\nThe <code>0x55</code> (“SSTORE”) opcode.\nThe <code>0xFA</code> (“STATICCALL”) opcode.\nThe <code>0xFA</code> (“STATICCALL”) opcode.\nThe <code>0x00</code> (“STOP”) opcode.\nThe <code>0x00</code> (“STOP”) opcode.\nThe <code>0x03</code> (“SUB”) opcode.\nThe <code>0x03</code> (“SUB”) opcode.\nThe <code>0x90</code> (“SWAP1”) opcode.\nThe <code>0x90</code> (“SWAP1”) opcode.\nThe <code>0x99</code> (“SWAP10”) opcode.\nThe <code>0x99</code> (“SWAP10”) opcode.\nThe <code>0x9A</code> (“SWAP11”) opcode.\nThe <code>0x9A</code> (“SWAP11”) opcode.\nThe <code>0x9B</code> (“SWAP12”) opcode.\nThe <code>0x9B</code> (“SWAP12”) opcode.\nThe <code>0x9C</code> (“SWAP13”) opcode.\nThe <code>0x9C</code> (“SWAP13”) opcode.\nThe <code>0x9D</code> (“SWAP14”) opcode.\nThe <code>0x9D</code> (“SWAP14”) opcode.\nThe <code>0x9E</code> (“SWAP15”) opcode.\nThe <code>0x9E</code> (“SWAP15”) opcode.\nThe <code>0x9F</code> (“SWAP16”) opcode.\nThe <code>0x9F</code> (“SWAP16”) opcode.\nThe <code>0x91</code> (“SWAP2”) opcode.\nThe <code>0x91</code> (“SWAP2”) opcode.\nThe <code>0x92</code> (“SWAP3”) opcode.\nThe <code>0x92</code> (“SWAP3”) opcode.\nThe <code>0x93</code> (“SWAP4”) opcode.\nThe <code>0x93</code> (“SWAP4”) opcode.\nThe <code>0x94</code> (“SWAP5”) opcode.\nThe <code>0x94</code> (“SWAP5”) opcode.\nThe <code>0x95</code> (“SWAP6”) opcode.\nThe <code>0x95</code> (“SWAP6”) opcode.\nThe <code>0x96</code> (“SWAP7”) opcode.\nThe <code>0x96</code> (“SWAP7”) opcode.\nThe <code>0x97</code> (“SWAP8”) opcode.\nThe <code>0x97</code> (“SWAP8”) opcode.\nThe <code>0x98</code> (“SWAP9”) opcode.\nThe <code>0x98</code> (“SWAP9”) opcode.\nThe <code>0xE7</code> (“SWAPN”) opcode.\nThe <code>0xE7</code> (“SWAPN”) opcode.\nThe <code>0x42</code> (“TIMESTAMP”) opcode.\nThe <code>0x42</code> (“TIMESTAMP”) opcode.\nThe <code>0x5C</code> (“TLOAD”) opcode.\nThe <code>0x5C</code> (“TLOAD”) opcode.\nThe <code>0x5D</code> (“TSTORE”) opcode.\nThe <code>0x5D</code> (“TSTORE”) opcode.\nThe <code>0x18</code> (“XOR”) opcode.\nThe <code>0x18</code> (“XOR”) opcode.\nReturns the opcode as a string. This is the inverse of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the opcode as a u8.\nReturns a mutable reference to the boxed instruction at …\nSets the immediate bytes number.\nReturns the size of the immediate value in bytes.\nReturns the opcode information.\nReturns the opcode information for the given opcode.\nReturns the number of both input and output stack elements.\nReturns the number of input stack elements.\nReturns the number of input stack elements.\nInserts the instruction into the table with the specified …\nInserts a boxed instruction into the table at the …\nReturns the instruction function for the given opcode and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculates the difference between the number of input and …\nCalculates the difference between the number of input and …\nReturns whether this opcode is disabled in EOF bytecode.\nReturns true if the opcode is a legacy jump instruction.\nTakes a u8 and returns true if it is a jump instruction.\nReturns true if the opcode is a jump destination.\nTakes a u8 and returns true if it is a jump destination.\nReturns true if the opcode is a <code>PUSH</code> instruction.\nTakes a u8 and returns true if it is a push instruction.\nReturns whether this opcode terminates execution, e.g. <code>STOP</code>…\nMake boxed instruction table that calls <code>f</code> closure for …\nMake instruction table.\nReturns true if the opcode modifies memory. …\nReturns the opcode name.\nReturns the opcode name.\nInstantiate a new opcode from a u8.\nCreates a new opcode info with the given name and default …\nCreates a plain instruction table for the given spec. See …\nInstantiate a new opcode from a u8 without checking if it …\nSets the EOF flag to false.\nReturns the number of output stack elements.\nReturns the number of output stack elements.\nParses an opcode from a string. This is the inverse of …\nReplaces a boxed instruction into the table at the …\nSets the number of stack inputs and outputs.\nSets the terminating flag to true.\nConverts the current instruction table to a boxed variant …\nConverts the current instruction table to a boxed variant …\nUpdates every instruction in the table by calling <code>f</code>.\nUpdates a single instruction in the table at the specified …\nUpdates a boxed instruction with a new one.")