searchState.loadedDescShard("revm", 2, "Returns the number of elements in the set.\nCreates an empty <code>HashSet</code>.\nEnsures a value is in the entry by inserting if it was …\nRemoves a value from the set. Returns whether the value was\nTakes the value out of the entry, and returns it. Keeps …\nAdds a value to the set, replacing the existing value, if …\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the set with a lower limit. It …\nShrinks the capacity of the set as much as possible. It …\nReturns the difference of <code>self</code> and <code>rhs</code> as a new …\nVisits the values representing the symmetric difference, …\nRemoves and returns the value in the set, if any, that is …\nTries to reserve capacity for at least <code>additional</code> more …\nVisits the values representing the union, i.e., all the …\nCreates an empty <code>HashSet</code> with at least the specified …\nCreates an empty <code>HashSet</code> with at least the specified …\nCreates a new empty hash set which will use the given …\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nError for <code>from_base_le</code> and <code>from_base_be</code>.\nError from <code>Uint::from_base_be</code>.\nA newtype wrapper around <code>Uint</code> that restricts operations to …\nError for <code>TryFrom&lt;Uint&gt;</code>.\nThe requested number base <code>.0</code> is less than two.\nThe provided digit <code>.0</code> is out of range for requested base <code>.1</code>…\nInvalid digit in string.\nInvalid radix, up to base 64 is supported.\nThe size of this integer type in 64-bit limbs.\n‘Not a number’ (NaN) can not be represented as Uint\nNumber is equal or larger than the target field modulus.\nThe value is too large to fit the target type.\nThe Uint value is too large for the target type.\nError for <code>from_str_radix</code>.\nError for <code>TryFrom&lt;Uint&gt;</code> for <code>ark_ff</code> and others.\nError for <code>TryFrom&lt;T&gt;</code> for <code>Uint</code>.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\nNegative values can not be represented as Uint.\nValue is too large to fit the Uint.\nThe value zero. This is the only value that exists in all …\n⚠️ Collection of bignum algorithms.\nType aliases for common bit sizes of <code>Uint</code> and <code>Bits</code>.\nSee <code>Uint::as_le_bytes</code> for documentation.\nSee <code>Uint::as_limbs</code> for documentation.\nSee <code>Uint::as_limbs_mut</code> for documentation.\nReturns a reference to the inner Uint.\nReturns a mutable reference to the inner Uint.\nSee <code>Uint::checked_shl</code> for documentation.\nSee <code>Uint::checked_shr</code> for documentation.\nCompile time for loops with a <code>const</code> variable for testing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSee <code>Uint::from_be_bytes</code> for documentation.\nSee <code>Uint::from_le_bytes</code> for documentation.\nSee <code>Uint::from_limbs</code> for documentation.\nSee <code>Uint::from_str_radix</code> for documentation.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner Uint.\nSee <code>Uint::leading_ones</code> for documentation.\nSee <code>Uint::leading_zeros</code> for documentation.\nMask to apply to the highest limb to get the correct …\nNumber of bytes required to represent the given number of …\nNumber of <code>u64</code> limbs required to represent the given number …\nSee <code>Uint::overflowing_shl</code> for documentation.\nSee <code>Uint::overflowing_shr</code> for documentation.\nSee <code>Uint::reverse_bits</code> for documentation.\nSee <code>Uint::rotate_left</code> for documentation.\nSee <code>Uint::rotate_right</code> for documentation.\nSupport for external crates.\nSee <code>Uint::to_be_bytes</code> for documentation.\nSee <code>Uint::to_be_bytes_vec</code> for documentation.\nSee <code>Uint::to_le_bytes</code> for documentation.\nSee <code>Uint::trailing_ones</code> for documentation.\nSee <code>Uint::trailing_zeros</code> for documentation.\nSee <code>Uint::try_from_be_slice</code> for documentation.\nSee <code>Uint::try_from_le_slice</code> for documentation.\nSee <code>Uint::wrapping_shl</code> for documentation.\nSee <code>Uint::wrapping_shr</code> for documentation.\n⚠️ Lehmer update matrix\n<code>lhs += rhs + carry</code>\nComputes <code>lhs += a</code> and returns the carry.\n⚠️ Computes <code>result += a * b</code> and checks for overflow.\nComputes wrapping <code>lhs += a * b</code> when all arguments are the …\nComputes <code>lhs += a * b</code> and returns the carry.\nApplies the matrix to a <code>Uint</code>.\nApplies the matrix to a <code>u128</code>.\nCompare two <code>u64</code> slices in reverse order.\nReturns the matrix product <code>self * other</code>.\n⚠️ Collection of division algorithms.\n⚠️ Division with remainder.\nCompute a Lehmer update matrix from two <code>Uint</code>s.\nReturns the argument unchanged.\nCompute the Lehmer update matrix in full 64 bit precision.\nCompute the Lehmer update matrix for small values.\nCompute the largest valid Lehmer update matrix for a …\n⚠️ Lehmer’s GCD algorithms.\n⚠️ Lehmer’s extended GCD.\nCalls <code>U::from(self)</code>.\n⚠️ Modular inversion using extended GCD.\nComputes <code>lhs *= a</code> and returns the carry.\nComputes a * b * 2^(-BITS) mod modulus\n<code>lhs -= rhs - borrow</code>\nComputes a^2 * 2^(-BITS) mod modulus\nComputes <code>lhs -= a * b</code> and returns the borrow.\n⚠️ Division with remainder.\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient of a 192 bits divided by a …\n⚠️ Computes the quotient of a 192 bits divided by a …\nTODO: This implementation is off by one.\n⚠️ Compute single limb division.\n⚠️ Compute single limb normalized division.\n⚠️ Compute double limb division.\n⚠️ Compute double limb normalized division.\n⚠️ In-place Knuth long division with implicit …\n⚠️ In-place Knuth normalized long division with …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathtt{d}}} - …\n<code>Bits</code> for <code>0</code> bits.\n<code>Bits</code> for <code>1</code> bits.\n<code>Bits</code> for <code>1024</code> bits.\n<code>Bits</code> for <code>128</code> bits.\n<code>Bits</code> for <code>16</code> bits.\n<code>Bits</code> for <code>160</code> bits.\n<code>Bits</code> for <code>192</code> bits.\n<code>Bits</code> for <code>2048</code> bits.\n<code>Bits</code> for <code>256</code> bits.\n<code>Bits</code> for <code>32</code> bits.\n<code>Bits</code> for <code>320</code> bits.\n<code>Bits</code> for <code>384</code> bits.\n<code>Bits</code> for <code>4096</code> bits.\n<code>Bits</code> for <code>448</code> bits.\n<code>Bits</code> for <code>512</code> bits.\n<code>Bits</code> for <code>64</code> bits.\n<code>Bits</code> for <code>768</code> bits.\n<code>Bits</code> for <code>8</code> bits.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n<code>Uint</code> for <code>128</code> bits. Similar to <code>u128</code>.\n<code>Uint</code> for <code>16</code> bits. Similar to <code>u16</code>.\n<code>Uint</code> for <code>160</code> bits.\n<code>Uint</code> for <code>192</code> bits.\n<code>Uint</code> for <code>2048</code> bits.\n<code>Uint</code> for <code>256</code> bits.\n<code>Uint</code> for <code>32</code> bits. Similar to <code>u32</code>.\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n<code>Uint</code> for <code>512</code> bits.\n<code>Uint</code> for <code>64</code> bits. Similar to <code>u64</code>.\n<code>Uint</code> for <code>768</code> bits.\n<code>Uint</code> for <code>8</code> bits. Similar to <code>u8</code>.\nThe prefix used for hashing messages according to EIP-191.\nEther is equivalent to 1e18 wei.\nGwei is equivalent to 1e9 wei.\nSigned 256-bit integer.\nThe provided units are not recognized.\nKwei is equivalent to 1e3 wei.\nSimple <code>Keccak-256</code> hasher.\nThe largest unit.\nThe smallest unit.\nMwei is equivalent to 1e6 wei.\nPwei is equivalent to 1e15 wei.\nOverflow when parsing a signed number.\nThis enum holds the numeric types that a possible to be …\nTwei is equivalent to 1e12 wei.\nUnsigned 256-bit integer.\nEthereum unit. Always less than <code>77</code>.\nError type for <code>Unit</code>-related operations.\nWei is equivalent to 1 wei.\nAllocates memory on the heap then places <code>x</code> into it, …\nConstructs a new box with uninitialized contents on the …\nHash a message according to EIP-191 (version <code>0x01</code>).\nConstructs a message according to EIP-191 (version <code>0x01</code>).\nFormats the given number of Wei as an Ether amount.\nFormats the given number of Wei as the given unit.\nFormats the given number of Wei as the given unit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the numeric value of the unit.\nReturns the absolute value of the number.\nReturns the signed value of the number.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the number is negative.\nReturns <code>true</code> if the number is positive.\nReturns <code>true</code> if the number is signed.\nReturns <code>true</code> if the number is unsigned.\nReturns <code>true</code> if the number is zero.\nSimple interface to the <code>Keccak-256</code> hash function.\nCreates a new <code>Unit</code> instance, checking for overflow.\nCreates a new <code>Unit</code> instance.\nConverts the input to a U256 and converts from Ether to …\nParses a decimal number and multiplies it with 10^units.\nParses a decimal number and multiplies it with 10^units.\nTries to collect the elements of an iterator into a <code>Vec</code>.\nTries to create a <code>Vec</code> with the given capacity.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nBit-Array Type Definition\nMemory Bus Access Management\nStatically-Allocated, Fixed-Size, Bit Buffer\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nHeap-Allocated, Fixed-Size, Bit Buffer\nMemory Region Description\nBit-Field Memory Slots\nBit Indices\nConstructor Macros\nMemory Element Descriptions\nIn-Element Bit Ordering\nSymbol Export\nRaw Pointer Implementation\nBit-Addressable Memory Regions\nStorage Memory Description\nDynamically-Allocated, Adjustable-Size, Bit Buffer\nBit View Adapters\nBit-Level Access Instructions\nRead-Only Semivolatile Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nThe element type being guarded against improper mutation.\nThe memory-access type this guards.\nThe zero constant.\nClears bits within a memory element to <code>0</code>.\nClears bits within a memory element to <code>0</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the function that will write <code>value</code> into all bits …\nGets the function that will write <code>value</code> into all bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverts bits within a memory element.\nInverts bits within a memory element.\nLoads the value from memory, allowing for the possibility …\nSets bits within a memory element to <code>1</code>.\nSets bits within a memory element to <code>1</code>.\nWrites a value to one bit in a memory element, returning …\nWrites a value to one bit in a memory element, returning …\nBit-Precision Array Immediate\nBit-Array Iteration\nA bit-array with all bits initialized to zero.\nThe ordering of bits within an <code>A::Store</code> element.\nExplicitly views the bit-array as a bit-slice.\nViews the remaining unyielded bits in the iterator.\nExplicitly views the bit-array as a mutable bit-slice.\nMutably views the remaining unyielded bits in the iterator.\nReturns a mutable bit-slice containing the entire …\nViews the bit-array as a mutable slice of its underlying …\nViews the bit-array as a slice of its underlying memory …\nReturns a bit-slice containing the entire bit-array. …\nThe wrapped data buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemoves the bit-array wrapper, returning the contained …\nTests whether the array is empty.\nGets the length (in bits) of the bit-array.\nWraps an existing buffer as a bit-array.\nConverts a bit-array into its iterator.\nFixed-Size, Heap-Allocated, Bit Slice\nAn iterator over a <code>BitBox</code>.\nViews the remaining unyielded bits as a bit-slice.\nExplicitly views the bit-box as a bit-slice.\nViews the remaining unyielded bits as a mutable bit-slice.\nExplicitly views the bit-box as a mutable bit-slice.\nViews the bit-box as a mutable slice of its underlying …\nViews the bit-box as a slice of its underlying memory …\nSets the unused bits outside the <code>BitBox</code> buffer to a fixed …\nEnsures that the allocated buffer has no dead bits between …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCopies a bit-slice region into a new bit-box allocation.\nConverts a <code>Box&lt;[T]&gt;</code> into a <code>BitBox&lt;T, O&gt;</code>, in place.\nConstructs a bit-box from a raw bit-slice pointer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the bit-box into a bit-vector.\nConverts the bit-box back into an ordinary boxed element …\nConsumes the bit-box, returning a raw bit-slice pointer.\nDeliberately leaks the allocated memory, returning an …\nAttempts to convert an ordinary boxed slice into a boxed …\nBit-Slice Partitioning\nBit-Slice Element Partitioning\nIndicates that a bit-slice’s contents are entirely in …\nIndicates that a bit-slice’s contents are entirely in …\nPartially-Owned Memory Element\nIndicates that a bit-slice’s contents touch an element …\nIndicates that a bit-slice’s contents touch an element …\nGets the semantic head and tail indices that constrain …\nClears all bits governed by the partial-element to <code>0</code>.\nAttempts to unpack the bit-domain as an <code>Enclave</code> variant. …\nAttempts to unpack the bit-domain as an <code>Enclave</code> variant. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the starting index of the live bits in the element.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the element-wise <code>Domain</code> into the equivalent …\nConverts the partial element into a bit-slice over its …\nInverts the value of each bit governed by the …\nFetches the value stored through <code>self</code> and masks away extra …\nGets the bit-mask over all accessible bits.\nAttempts to unpack the bit-domain as a <code>Region</code> variant. …\nAttempts to unpack the bit-domain as a <code>Region</code> variant. …\nSets all bits governed by the partial-element to <code>1</code>.\nStores a value through <code>self</code> after masking away extra bits.\nPerforms a store operation on a partial-element whose bits …\nGets the ending index of the live bits in the element.\nAny bits that wholly-fill elements in the interior of the …\nAny bits that partially-fill the first element of the …\nAny bits that partially-fill the last element of the …\nAll fully-used elements in the bit-slice’s underlying …\nThe first element in the bit-slice’s underlying storage, …\nThe last element in the bit-slice’s underlying storage, …\nC-Style Bit-Field Access\nInteger Loading\nInteger Loading\nInteger Loading\nInteger Loading\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nInteger Storing\nInteger Storing\nInteger Storing\nInteger Storing\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nA full bit-mask with every bit set.\nOne-Bit-After Tail Index\nSemantic Bit Index\nBit Index Error\nMulti-Bit Selection Mask\nBit Position\nOne-Hot Bit Selection Mask\nThe inclusive maximum index within an <code>R</code> element.\nThe inclusive maximum tail within (or after) an <code>R</code> element.\nThe position value of the most significant bit in an <code>R</code> …\nThe inclusive minimum index within an <code>R</code> element.\nThe inclusive minimum tail within (or after) an <code>R</code> element.\nThe position value of the least significant bit in an <code>R</code> …\nAn empty bit-mask with every bit cleared.\nCreates a new mask with a selector bit activated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts a selector bit into a mask.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemoves the index wrapper, leaving the internal counter.\nRemoves the error wrapper, leaving the internal counter.\nRemoves the tail wrapper, leaving the internal counter.\nRemoves the position wrapper, leaving the internal counter.\nRemoves the one-hot selection wrapper, leaving the …\nRemoves the mask wrapper, leaving the internal value.\nComputes the bit selector for <code>self</code> as an accessor mask.\nComputes the bit selector for <code>self</code> as an accessor mask.\nComputes a bit-mask for <code>self</code>. This is a type-cast.\nWraps a counter value as a known-good index into an <code>R</code> …\nWraps a counter value as a known-good tail of an <code>R</code> …\nWraps a counter value as a known-good position within an <code>R</code> …\nWraps a selector value as a known-good selection in an <code>R</code> …\nWraps any <code>R</code> value as a bit-mask.\nWraps a counter value as an assumed-good index into an <code>R</code> …\nWraps a counter value as an assumed-good position within …\nWraps a selector value as an assumed-good selection in an <code>R</code>…\nIncrements an index counter, wrapping at the back edge of …\nComputes the bit position corresponding to <code>self</code> under some …\nDecrements an index counter, wrapping at the front edge of …\nIterates over all indices between an inclusive start and …\nIterates over all possible index values.\nIterates over all possible selector values.\nIterates over all tail indices at and after an inclusive …\nComputes the bit selector corresponding to <code>self</code> under an …\nComputes the bit selector corresponding to <code>self</code>.\nTests if a mask contains a given selector bit.\nThe literal <code>!0</code>.\nRegister Descriptions\nThe number of bits required to store an index in the range …\nThe number of bits required to store an index in the range …\nA mask over all bits that can be used as an index within …\nA mask over all bits that can be used as an index within …\nCounts the number of bits in a value of type <code>T</code>.\nBit Storage Calculator\nIn-Element Bit Ordering\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nMost-Significant-First Bit Traversal\nTranslates a semantic bit index into a real bit position.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProduces a multi-bit selection mask from a range of …\nProduces a multi-bit selection mask from a range of …\nProduces a multi-bit selection mask from a range of …\nProduces a multi-bit selection mask from a range of …\nProduces a single-bit selection mask from a bit-index.\nProduces a single-bit selection mask from a bit-index.\nProduces a single-bit selection mask from a bit-index.\nProduces a single-bit selection mask from a bit-index.\nComplete <code>BitOrder</code> Verification\nSingle-Type <code>BitOrder</code> Verification\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nImmutable Bit View\nMutable Bit View\nBit-Array Type Definition\nBit-Precision Array Immediate\nFixed-Size, Heap-Allocated, Bit Slice\nIn-Element Bit Ordering\nSingle-Bit Pointer\nBit-Pointer Range\nProxy Bit-Reference\nBit-Addressable Memory\nBit Storage\nBit-Precision Dynamic Array\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nThe element type used in the memory region underlying a …\nMost-Significant-First Bit Traversal\nThe underlying element type.\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nThe zero constant.\nBit View\nC-Style Bit-Field Access\nHelper trait for scalars and arrays, but not slices.\nThe ordering of bits within an <code>A::Store</code> element.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nTranslates a semantic bit index into a real bit position.\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nThe wrapped data buffer.\nThe higher, exclusive, bound of the range. The bit to …\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nLoads a value out of the memory system according to the …\nWraps a raw memory value as a <code>BitStore</code> type.\nThe lower, inclusive, bound of the range. The bit to which …\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nStores a value into the memory system. This is only called …\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nSingle-Bit Pointer\nErrors produced by invalid bit-pointer components.\nBit-Pointer Range\nProxy Bit-Reference\nAn error produced when creating <code>BitSpan</code> encoded references.\nMarks whether this type contains mutability permissions …\nMarks whether this type contains mutability permissions …\nA basic <code>const</code> marker.\nThe canonical dangling pointer. This selects the starting …\nThe canonical empty range. All ranges with zero length …\nThe error produced when an address is insufficiently …\nAttempted to construct a bit-pointer with an address not …\nThe base element pointer is not aligned.\nA basic <code>mut</code> marker.\nGeneralized mutability permissions.\nAttempted to construct a bit-pointer with the null element …\nA null pointer was provided.\nCounts the layers of <code>Frozen&lt;&gt;</code> wrapping around a base <code>Const</code> …\nCounts the layers of <code>Frozen&lt;&gt;</code> wrapping around a base <code>Const</code> …\nOne of <code>*const</code> or <code>*mut</code>.\nAllow instances to be constructed generically.\nThe requested address is too high, and wraps to zero.\nThe requested length exceeds the <code>BitSpan</code> length ceiling.\nAdjusts a bit-pointer upwards in memory. This is …\nGets the address of the base storage element.\nComputes the offset (in bits) that needs to be applied to …\nProduces a proxy reference to the referent bit.\nProduces a proxy reference to the referent bit.\nGets the <code>BitIdx</code> that selects the bit within the memory …\nBit-Slice Pointer Construction\nBit-Slice Pointer Construction\nCasts to a <code>BitPtr</code> with a different storage parameter.\nEnsures that an address is well-aligned to its referent …\nCommits a bit into the proxied location.\nTests if a given bit-pointer is contained within the range.\nBit-wise <code>memcpy</code>\nCopies <code>count</code> bits from the region starting at <code>src</code> to the …\nCopies <code>count</code> bits from the region starting at <code>src</code> to the …\nBit-wise <code>memcpy</code>\nCopies <code>count</code> bits from <code>self</code> to <code>dest</code>. The source and …\nCopies <code>count</code> bits from <code>self</code> to <code>dest</code>. The source and …\nRemote Destructor\nRuns the destructor of the referent value.\nThe higher, exclusive, bound of the range. The bit to …\nBit-Pointer Equality\nFreeze this type, wrapping it in a <code>const</code> marker that may …\nFreeze this type, wrapping it in a <code>const</code> marker that may …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a bit-pointer into a proxy bit-reference.\nConstructs a mutable <code>BitPtr</code> to the zeroth bit in a single …\nConstructs a <code>BitPtr</code> to the zeroth bit in the zeroth …\nExplicitly converts a <code>Range&lt;BitPtr&gt;</code> into a <code>BitPtrRange</code>.\nConstructs a <code>BitPtr</code> to the zeroth bit in a single element.\nConstructs a <code>BitPtr</code> to the zeroth bit in the zeroth …\nConstructs a mutable <code>BitPtr</code> to the zeroth bit in the …\nBit-Pointer Hashing\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecays the bit-reference to an ordinary bit-pointer.\nExplicitly converts a <code>BitPtrRange</code> into a <code>Range&lt;BitPtr&gt;</code>.\nTests if the range is empty (the distance between …\nTests if a bit-pointer is the null value.\nTries to construct a <code>BitPtr</code> from a memory location and a …\nConstructs a <code>BitPtr</code> from an address and head index, …\nBit-Pointer Sentinel Value\nBit-Pointer Sentinel Value\nCreates a new bit-pointer at a specified offset from the …\nCalculates the distance (in bits) between two bit-pointers.\nGets a raw pointer to the memory element containing the …\nGets a raw pointer to the memory location containing the …\nDecomposes a bit-pointer into its element address and bit …\nSingle-Bit Read\nReads the bit from <code>*self</code>.\nSingle-Bit Unaligned Read\nReads the bit from <code>*self</code> using an unaligned memory access.\nSingle-Bit Volatile Read\nReads the bit from <code>*self</code> using a volatile load.\nSingle-Bit Replacement\nMoves <code>src</code> into the referenced bit, returning the previous …\nReplaces the bit at <code>*self</code> with a new value, returning the …\nWrites <code>value</code> into the proxy.\nRaw Bit-Slice Pointer Construction\nRaw Bit-Slice Pointer Construction\nThe lower, inclusive, bound of the range. The bit to which …\nAdjusts a bit-pointer downwards in memory. This is …\nBit Swap\nSwaps the bit values of two proxies.\nSwaps the bits at two mutable locations.\nMany-Bit Swap\nThaw a previously-frozen type, removing its <code>Frozen</code> marker …\nThaw a previously-frozen type, removing its <code>Frozen</code> marker …\nRemoves write permissions from a bit-pointer.\nAdds write permissions to a bit-pointer.\nDecomposes a bit-pointer into its address and head-index …\nAdjusts a bit-pointer upwards in memory, using wrapping …\nCreates a new bit-pointer at a specified offset from the …\nAdjusts a bit-pointer downwards in memory, using wrapping …\nSingle-Bit Write\nWrites a new bit into the given location.\nBit-wise <code>memset</code>\nBit-wise <code>memset</code>\nSingle-Bit Unaligned Write\nWrites a bit into memory, tolerating unaligned addresses.\nSingle-Bit Volatile Write\nWrites a new bit using volatile I/O operations.\nAn iterator over <code>BitSlice</code> that yields <code>&amp;bool</code> directly.\nBit-Addressable Memory\nBit-Slice Indexing\nAn iterator over <code>BitSlice</code> that yields <code>bool</code> directly.\nShared Bit-Slice Chunking\nShared Bit-Slice Exact Chunking\nExclusive Bit-Slice Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nThe output type of immutable access.\nShared Bit-Slice Iteration\nExclusive Bit-Slice Iteration\nAnti-Aliasing Iterator Adapter\nBit Seeking\nBit Seeking\nThe inclusive maximum length of a <code>BitSlice&lt;_, T&gt;</code>.\nThe inclusive maximum length that a <code>[T]</code> slice can be for …\nThe output type of mutable access.\nShared Bit-Slice Reverse Chunking\nShared Bit-Slice Reverse Exact Chunking\nExclusive Bit-Slice Reverse Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nBit-Slice Windowing\nProduces bit-slice view(s) with different underlying …\nProduces bit-slice view(s) with different underlying …\nTests if every bit is set to <code>1</code> in the bit-slice.\nTests if there is at least one bit set to <code>1</code> in the …\nGets a raw pointer to the zeroth bit of the bit-slice.\nViews the bit-slice as a half-open range of bit-pointers, …\nViews the currently unyielded bit-slice.\nViews the remaining bit-slice that has not yet been …\nGets a raw, write-capable pointer to the zeroth bit of the …\nViews the bit-slice as a half-open range of write-capable …\nProduces a range of mutable bit-pointers to each bit in …\nProduces a range of bit-pointers to each bit in the …\nPartitions a bit-slice into maybe-contended and …\nPartitions a mutable bit-slice into maybe-contended and …\nBoolean Arithmetic\nBoolean Arithmetic\nBoolean Arithmetic\nAdapts the iterator to yield regular <code>&amp;bool</code> references …\nAdapts the iterator to yield <code>bool</code> values rather than the …\nIterates over non-overlapping subslices of a bit-slice.\nIterates over non-overlapping subslices of a bit-slice.\nIterates over non-overlapping mutable subslices of a …\nIterates over non-overlapping mutable subslices of a …\nCopies the bits from <code>src</code> into <code>self</code>.\nTests if the bit-slice contains the given sequence …\nYields <code>bool</code> values directly, rather than proxy references.\nCopies all bits from <code>src</code> into <code>self</code>, using batched …\nCopies a span of bits to another location in the bit-slice.\nCopies bits from one region of the bit-slice to another …\nCounts the number of bits set to <code>1</code> in the bit-slice …\nCounts the number of bits cleared to <code>0</code> in the bit-slice …\nViews the underlying memory of a bit-slice, removing alias …\nViews the underlying memory of a bit-slice, removing alias …\nProduces an empty bit-slice with an arbitrary lifetime.\nProduces an empty bit-slice with an arbitrary lifetime.\nTests if the bit-slice ends with the given sequence.\nFills the bit-slice with a given bit.\nFills the bit-slice with bits produced by a generator …\nGets a reference to the first bit of the bit-slice, or <code>None</code>…\nGets a mutable reference to the first bit of the …\nFinds the index of the first bit in the bit-slice set to <code>1</code>.\nFinds the index of the first bit in the bit-slice cleared …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a shared <code>&amp;BitSlice</code> reference over a shared …\nConstructs an exclusive <code>&amp;mut BitSlice</code> reference over an …\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nConstructs a shared <code>&amp;BitSlice</code> reference over a slice of …\nConstructs an exclusive <code>&amp;mut BitSlice</code> reference over a …\nConstructs a shared <code>&amp;BitSlice</code> over an element slice, …\nConstructs an exclusive <code>&amp;mut BitSlice</code> over an element …\nImmutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nGets a reference to a single bit or a subsection of the …\nMutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nGets a mutable reference to a single bit or a subsection …\nImmutably indexes into a bit-slice without doing any …\nGets a reference to a single bit or to a subsection of the …\nMutably indexes into a bit-slice without doing any bounds …\nGets a mutable reference to a single bit or a subsection …\nImmutably indexes into a bit-slice, panicking if <code>self</code> is …\nLooks up a single bit by its semantic index.\nMutably indexes into a bit-slice, panicking if <code>self</code> is out …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nViews the underlying bit-slice as a subslice of the …\nConsumes the iterator, returning the remnant bit-slice …\nConsumes the iterator, returning the remnant bit-slice …\nSee <code>ChunksExactMut::into_remainder()</code>.\nSee <code>RChunksExactMut::into_remainder()</code>\nTests if the bit-slice is empty (length zero).\nProduces an iterator over each bit in the bit-slice.\nProduces a mutable iterator over each bit in the bit-slice.\nEnumerates the index of each bit in a bit-slice set to <code>1</code>.\nEnumerates the index of each bit in a bit-slice cleared to …\nGets a reference to the last bit of the bit-slice, or <code>None</code> …\nGets a mutable reference to the last bit of the bit-slice, …\nFinds the index of the last bit in the bit-slice set to <code>1</code>.\nFinds the index of the last bit in the bit-slice cleared …\nCounts the number of bits from the start of the bit-slice …\nCounts the number of bits from the start of the bit-slice …\nGets the number of bits in the bit-slice.\n<code>Msb0</code> Big-Endian Integer Loading\n<code>Lsb0</code> Big-Endian Integer Loading\n<code>Msb0</code> Little-Endian Integer Loading\n<code>Lsb0</code> Little-Endian Integer Loading\nTests if at least one bit is cleared to <code>0</code> in the bit-slice.\nTests if every bit is cleared to <code>0</code> in the bit-slice.\nIterates over non-overlapping subslices of a bit-slice, …\nIterates over non-overlapping subslices of a bit-slice, …\nIterates over non-overlapping mutable subslices of a …\nIterates over non-overlapping mutable subslices of a …\nGets the remnant bit-slice that the iterator will not …\nGets the remnant bit-slice that the iterator will not …\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nRemoves a layer of <code>::Alias</code> tainting from the yielded item.\nCreates a bit-vector by repeating a bit-slice <code>n</code> times.\nWrites a new value into a bit, and returns its previous …\nWrites a new value into a bit, returning the previous …\nReverses the order of bits in a bit-slice.\nRotates the contents of a bit-slice to the left (towards …\nRotates the contents of a bit-slice to the right (away …\nIterates over subslices separated by bits that match a …\nIterates over mutable subslices separated by bits that …\nIterates over mutable subslices separated by bits that …\nIterates over mutable subslices separated by bits that …\nWrites a new value into a single bit.\nWrites a new value into a single bit, using alias-safe …\nWrites a new value into a single bit, using alias-safe …\nWrites a new value into a single bit, without bounds …\nShifts the contents of a bit-slice “left” (towards the …\nShifts the contents of a bit-slice “right” (away from …\nTests if at least one bit is set to <code>1</code>, and at least one …\nIterates over subslices separated by bits that match a …\nSplits a bit-slice in two parts at an index.\nSplits a mutable bit-slice in two parts at an index.\nSplits a bit-slice at an index, without bounds checking.\nSplits a mutable bit-slice at an index, without bounds …\nSplits the bit-slice into a reference to its first bit, …\nSplits the bit-slice into mutable references of its first …\nIterates over subslices separated by bits that match a …\nIterates over mutable subslices separated by bits that …\nSplits the bit-slice into a reference to its last bit, and …\nSplits the bit-slice into mutable references to its last …\nIterates over mutable subslices separated by bits that …\nIterates over subslices separated by bits that match a …\nIterates over mutable subslices separated by bits that …\nTests if the bit-slice begins with the given sequence.\n<code>Lsb0</code> Big-Endian Integer Storing\n<code>Msb0</code> Big-Endian Integer Storing\n<code>Lsb0</code> Little-Endian Integer Storing\n<code>Msb0</code> Little-Endian Integer Storing\nRemoves a prefix bit-slice, if present.\nRemoves a suffix bit-slice, if present.\nExchanges the bit values at two indices.\nSwaps two bits in a bit-slice, without bounds checking.\nSwaps the contents of two bit-slices.\nTakes the remnant bit-slice out of the iterator.\nTakes the remnant bit-slice out of the iterator.\nSee <code>ChunksExactMut::take_remainder()</code>\nSee <code>RChunksExactMut::take_remainder()</code>\nCopies a bit-slice into an owned bit-vector.\nCounts the number of bits from the end of the bit-slice to …\nCounts the number of bits from the end of the bit-slice to …\nAttempts to construct a shared <code>&amp;BitSlice</code> reference over a …\nAttempts to construct an exclusive <code>&amp;mut BitSlice</code> reference …\nIterates over consecutive windowing subslices in a …\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nBit Storage\nThe element type used in the memory region underlying a …\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nReads a single bit out of the memory system according to …\nReads a single bit out of the memory system according to …\nReads a single bit out of the memory system according to …\nReads a single bit out of the memory system according to …\nLoads a value out of the memory system according to the …\nWraps a raw memory value as a <code>BitStore</code> type.\nStores a value into the memory system. This is only called …\nBit-Precision Dynamic Array\nDraining Iteration\nAn empty bit-vector with no backing allocation.\nAn iterator over a <code>BitBox</code>.\nSplicing Iteration\nMoves all the bits out of <code>other</code> into the back of <code>self</code>.\nCreates an unsafe shared bit-pointer to the start of the …\nViews the unyielded bits remaining in the drain.\nExplicitly views the bit-vector as a bit-slice.\nCreates an unsafe writable bit-pointer to the start of the …\nExplicitly views the bit-vector as a mutable bit-slice.\nViews the bit-vector as a mutable slice of its underlying …\nViews the bit-vector as a slice of its underlying memory …\nGets the allocation capacity, measured in bits.\nEmpties the bit-vector.\nIterates over a portion of the bit-vector, <em>removing</em> all …\nAppends the contents of a bit-slice to a bit-vector.\nAppends a slice of <code>T</code> elements to a bit-vector.\nExtends <code>self</code> by copying an internal range of its bit-slice …\nEnsures that the live region of the bit-vector’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCopies the contents of a bit-slice into a new heap …\nConstructs a new bit-vector from a single element.\nConstructs a bit-vector handle from its constituent fields.\nConstructs a new bit-vector from a slice of memory …\nConverts a regular vector in-place into a bit-vector.\nInserts a bit at a given position, shifting all bits after …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a bit-vector into a boxed bit-slice.\nDecomposes a bit-vector into its constituent member fields.\nConverts a bit-vector into a <code>Vec</code> of its underlying storage.\nTests if the bit-vector is empty.\nDestroys the <code>BitVec</code> handle without destroying the …\nGets the length of the bit-vector.\nConstructs a new, empty, bit-vector.\nAttempts to remove the trailing bit from the bit-vector.\nAppends a single bit to the vector.\nRemoves a bit at a given position, shifting all bits after …\nCreates a new bit-vector by repeating a bit for the …\nEnsures that the bit-vector has allocation capacity for <em>at </em>…\nEnsures that the bit-vector has allocation capacity for <em>at </em>…\nResizes the bit-vector to a new length. New bits are …\nResizes the bit-vector to a new length, using a function …\nRetains only the bits that the predicate allows.\nOverwrites each element (visible in <code>.as_raw_mut_slice()</code>) …\nResizes a bit-vector to a new length.\nSets the uninitialized bits of a bit-vector to a known …\nReleases excess capacity back to the allocator.\nModifies <code>self.drain()</code> so that the removed bit-slice is …\nSplits the bit-vector in half at an index, moving …\nTakes a bit out of the bit-vector.\nShortens the bit-vector, keeping the first <code>new_len</code> bits …\nFallibly constructs a new bit-vector from a slice of …\nAttempts to convert a regular vector in-place into a …\nAllocates a new, empty, bit-vector with space for at least …\nImmutable Bit View\nMutable Bit View\nBit View\nHelper trait for scalars and arrays, but not slices.\nThe underlying element type.\nThe zero constant.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nWraps <code>self</code> in a <code>BitArray</code>.\nWraps <code>self</code> in a <code>BitArray</code>.\nWraps <code>self</code> in a <code>BitArray</code>.\nWraps <code>self</code> in a <code>BitArray</code>.\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nEVM database interface.\nEVM database commit interface.\nEVM database interface.\nThe database error type.\nThe database error type.\nWraps a <code>DatabaseRef</code> to provide a <code>Database</code> implementation.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet block hash by block number\nGet block hash by block number\nGet block hash by block number.\nGet block hash by block number.\nGet account code by its hash\nGet account code by its hash\nGet account code by its hash.\nGet account code by its hash.\nCommit changes to the database.\nDatabase that is split on State and BlockHash traits.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet basic account information.\nGet basic account information.\nBlockHash database component from <code>crate::db::Database</code> it …\nGet block hash by block number\nGet block hash by block number\nGet account code by its hash\nGet account code by its hash\nState database component from <code>crate::db::Database</code> it is …\nGet storage value of address at index.\nGet storage value of address at index.\nGet block hash by block number\nGet block hash by block number\nGet basic account information.\nGet basic account information.\nGet account code by its hash\nGet account code by its hash\nGet storage value of address at index.\nGet storage value of address at index.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nIndicates a failed recovery attempt where no valid address …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nCost of creating authorized account that was previously …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nOnly supported version is version 0x00.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nIndicates a failed recovery attempt where no valid address …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nOnly supported version is version 0x00.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nStructure holding block blob excess gas and it calculates …\nThe block environment.\nA transaction that calls a contract or transfer.\nEVM configuration.\nConfiguration environment with the chain spec id.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nCreate scheme of <code>CREATE2</code>.\nCreate scheme.\nEVM environment configuration.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nDo not perform bytecode analysis.\nTransaction destination\nThe transaction environment.\nA list of addresses and storage keys that the transaction …\nList of authorizations, that contains the signature that …\nThe base fee per gas, added in the London upgrade with …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\nCoinbase or miner or address that created and signed the …\nThe data of the transaction.\nThe difficulty of the block.\nEvm environment.\nThe excess blob gas of the block.\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nHandler configuration fields.\nHandler configuration fields.\nKZG Settings for point evaluation precompile. By default, …\nIf some it will effects EIP-170: Contract code size limit. …\nThe max fee per blob gas.\nThe nonce of the transaction.\nThe number of ancestor blocks of this block (block height).\nBytecode that is created with CREATE/CREATE2 is by default …\nThe output of the randomness beacon provided by the beacon …\nSpecification identification.\nThe timestamp of the block in seconds since the UNIX epoch.\nThe destination of the transaction.\nConfiguration of the transaction that is being executed.\nThe value sent to <code>transact_to</code>.\nSalt.\nConfiguration environment with the chain spec id.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nConfiguration environment.\nEvm environment.\nHandler configuration fields.\nHandler configuration fields.\nSpecification identification.\nBody size is more than specified in the header.\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nEVM Object Format (EOF) container.\nEOF container body.\nEOF decode errors.\nEOF Header containing\nInvalid number for code kind\nInvalid data kind\nInvalid EOF magic number.\nInvalid initcode size.\nInvalid EOF version.\nInvalid kind after code\nInvalid terminal code\nInvalid number for types kind\nInvalid types section data.\nInvalid types section size.\nMismatch of code and types sizes.\nShort body while processing EOF.\nShort input while processing EOF.\nThere should be at least one size.\nMissing size.\nInvalid code number.\nInvalid container number.\nTypes section that contains stack information for matching …\nInvalid number of code sections.\nSize cant be zero\nReturns body size. It is sum of code sizes, container …\nReturns the code section at the given index.\nSizes of EOF code section. Code size can’t be zero.\nEOF Container size. Container size can be zero.\nEOF data size.\nReturn index where data size starts. Data size is two …\nDecodes an EOF container body from the given buffer and …\nDecodes EOF header from binary form.\nDecode the section from the input.\nEncodes this body into the given buffer.\nEncodes EOF header into binary form.\nEncode the section into the buffer.\nReturns raw size of the EOF.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ninputs - 1 byte - <code>0x00-0x7F</code> number of stack elements the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an EOF container from this body.\nCalculates the difference between the number of input and …\nTrue if section is non-returning.\nmax_stack_height - 2 bytes - <code>0x0000-0x03FF</code> maximum number …\nReturns new <code>TypesSection</code> with the given inputs, outputs, …\noutputs - 1 byte - <code>0x00-0x80</code> number of stack elements the …\nLength of the header in bytes.\nsum code sizes\nsum container sizes\nReturns number of types.\nSize of EOF types section. types section includes num of …\nValidate the section.\nCustom trusted setup.\nDefault mainnet trusted setup\nKZG Settings that allow us to specify a custom trusted …\nStores the setup and parameters needed for computing KZG …\nA map of valid <code>jump</code> destinations.\nLegacy analyzed\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nSimilar to Standard but takes reference to environment.\nContains the error value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nPrecompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nOutput bytes.\nGas used by the precompile.\nAccess list is not supported for blocks before the Berlin …\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\nBlob transaction can’t be a create transaction. <code>to</code> must …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCustom error.\nDatabase error.\nEOF Subroutine stack overflow\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHeader validation error.\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nTransaction validation error.\nTransaction account does not have enough amount of ether …\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nOutput of a transaction execution.\nOverflow payment in transaction.\nPrecompile error.\n<code>prevrandao</code> is not set for Merge and above.\nWhen using the EIP-1559 fee model introduced in the London …\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction validation error.\nStatus of execution\nState that got updated\nHalting will spend all the gas, and will be equal to …\nThe specification ID.\nSpecification IDs and their activation block.\nAccountInfo account information.\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\nStructure used for EIP-1153 transient storage.\nAccount balance.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nAccount nonce.\nOriginal value of the storage slot.\nPresent value of the storage slot.\nAccount status flags.\nStorage cache\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nSimple interface to the <code>Keccak-256</code> hash function.")