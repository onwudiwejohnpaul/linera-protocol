searchState.loadedDescShard("revm", 1, "Precompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nReturns reference of address.\nThe address which emitted this log.\nReturns an iterator over the precompiles addresses.\nReturns the precompiles addresses as a set.\nReturns precompiles for Berlin spec.\nOutput bytes.\nReturns precompiles for Byzantium spec.\nReturns precompiles for Cancun spec.\nIs the given address a precompile.\nThe log data.\nExtends the precompiles with the given precompiles.\nDisable kzg precompile. This will return Fatal error on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the appropriate precompile Spec for the primitive …\nGas used by the precompile.\nReturns the precompile for the given address.\nReturns the precompile for the given address.\nReturns precompiles for Homestead spec.\nReturns inner HashMap of precompiles.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the type and returns all precompile addresses.\nIs the precompiles list empty.\nReturns precompiles for Istanbul spec.\nReturns the precompiles for the latest spec.\nReturns the number of precompiles.\nReturns the precompiles for the given spec.\nReturns precompiles for Prague spec.\nReturns reference of precompile.\nConst function for making an address by concatenating the …\nreference: https://eips.ethereum.org/EIPS/eip-152 input …\ngot IV from: …\nSIGMA from spec: …\nG function: https://tools.ietf.org/html/rfc7693#section-3.1\nReturns the BLS12-381 precompiles with their addresses.\nBLS12_G1ADD precompile address.\nEIP-2537 BLS12_G1ADD precompile.\nBLS12_G1MSM precompile address.\nDiscounts table for G1 MSM as a vector of pairs …\nEIP-2537 BLS12_G1MSM precompile.\nBLS12_G2ADD precompile address.\nEIP-2537 BLS12_G2ADD precompile.\nBLS12_G2MSM precompile address.\nEIP-2537 BLS12_G2MSM precompile.\nBLS12_MAP_FP2_TO_G2 precompile address.\nEIP-2537 BLS12_MAP_FP2_TO_G2 precompile.\nBLS12_MAP_FP_TO_G1 precompile address.\nEIP-2537 BLS12_MAP_FP_TO_G1 precompile.\nBLS12_PAIRING precompile address.\nEIP-2537 BLS12_PAIRING precompile.\nInput length for the add operation. <code>ADD</code> takes two …\nInput length for the multiplication operation. <code>MUL</code> takes …\nPair element length. <code>PAIR</code> elements are composed of an …\nCreates a new <code>G1</code> point from the given <code>x</code> and <code>y</code> coordinates.\nReads a single <code>Fq</code> from the input slice.\nReads the <code>x</code> and <code>y</code> points from the input slice.\nFatal precompile that returns Fatal error on precompile …\nDisable kzg precompile. This will return Fatal error on …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new fatal precompile\nCreate a new stateful fatal precompile\nComputes the RIPEMD-160 hash of the input data.\nComputes the SHA-256 hash of the input data.\nThe base cost of the operation.\nThe cost per word.\nTakes the input bytes, copies them, and returns it as the …\n…\n<code>VERSIONED_HASH_VERSION_KZG ++ sha256(commitment)[1..]</code>\nRun kzg point evaluation precompile.\nSee: https://eips.ethereum.org/EIPS/eip-198 See: …\nAccessList as defined in EIP-2930\nA list of addresses and storage keys that the transaction …\nAccess list is not supported for blocks before the Berlin …\nAccountInfo account information.\nAn Ethereum address, 20 bytes in length.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\n32-byte fixed byte-array type.\nControls the maximum rate of change for blob gas price.\nControls the maximum rate of change for blob gas price …\nEIP-2935: Serve historical block hashes from state\nEIP-2935: Serve historical block hashes from state\nNumber of block hashes that EVM can access in the past …\nBlob transaction can’t be a create transaction. <code>to</code> must …\nStructure holding block blob excess gas and it calculates …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nThe block environment.\nState of the <code>Bytecode</code> analysis.\nEOF decode errors.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nA transaction that calls a contract or transfer.\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nEVM configuration.\nConfiguration environment with the chain spec id.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nA transaction that creates a contract.\nCreate scheme of <code>CREATE2</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCreate scheme.\nCustom trusted setup.\nCustom error.\nDatabase error.\nDefault mainnet trusted setup\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEOF Subroutine stack overflow\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEIP-7702 delegated bytecode\nEIP-7702 decode error\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nEVM environment configuration.\nSimilar to Standard but takes reference to environment.\nKZG Settings that allow us to specify a custom trusted …\nEvm environment with the chain spec id.\nEVM Object Format (EOF) container.\nEthereum Object Format\nEOF decode error\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\nContains the error value\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nA byte array of fixed length (<code>[u8; N]</code>).\nGas consumption of a single data blob (== blob byte size).\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHandler configuration fields. It is used to configure the …\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nHeader validation error.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\nIndicates a failed recovery attempt where no valid address …\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nTransaction validation error.\nA map of valid <code>jump</code> destinations.\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nStores the setup and parameters needed for computing KZG …\nTransaction account does not have enough amount of ether …\nThe bytecode has been analyzed for valid jump destinations.\nLegacy analyzed\nNo analysis has been performed.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nEIP-170: Contract code size limit\nEIP-3860: Limit and meter initcode\nMinimum gas price for data blobs.\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nOutput of a transaction execution.\nOverflow payment in transaction.\nThe address of precompile 3, which is handled specially in …\nPrecompile and its handlers.\nPrecompile error.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\n<code>prevrandao</code> is not set for Merge and above.\nAn Ethereum ECDSA signature.\nWhen using the EIP-1559 fee model introduced in the London …\nDo not perform bytecode analysis.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nThe specification ID.\nA signed EIP-7702 authorization.\nSpecification IDs and their activation block.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction destination\nTransaction validation error.\nStructure used for EIP-1153 transient storage.\nThe transaction environment.\nThe <code>to</code> field of a transaction. Either a target address, or …\n256-bit unsigned integer type, consisting of 4, 64-bit …\nOnly supported version is version 0x00.\nFirst version of the blob.\nIndicates a successfully recovered authority address.\nA list of addresses and storage keys that the transaction …\nAccount addresses that would be loaded at the start of …\nThe address of the authorization.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nList of authorizations, that contains the signature that …\nConverts a sequence of string literals containing …\nAccount balance.\nThe base fee per gas, added in the London upgrade with …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nOutput bytes.\nConverts a sequence of string literals containing …\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nThe chain ID of the authorization.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nCoinbase or miner or address that created and signed the …\nThe data of the transaction.\nThe plain data.\nThe log data.\nThe difficulty of the block.\nEvm environment.\nThe excess blob gas of the block.\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nConverts a sequence of string literals containing …\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nGas used by the precompile.\nHandler configuration fields.\nHandler configuration fields.\nMacro for converting sequence of string literals …\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nSimple interface to the <code>Keccak-256</code> hash function.\nKZG Settings for point evaluation precompile. By default, …\nIf some it will effects EIP-170: Contract code size limit. …\nThe max fee per blob gas.\nThe nonce for the authorization.\nThe nonce of the transaction.\nAccount nonce.\nThe number of ancestor blocks of this block (block height).\nOriginal value of the storage slot.\nBytecode that is created with CREATE/CREATE2 is by default …\nPresent value of the storage slot.\nThe output of the randomness beacon provided by the beacon …\nStatus of execution\nSpecification identification.\nState that got updated\nAccount status flags.\nStorage cache\nKeys of storage that would be loaded at the start of …\nThe timestamp of the block in seconds since the UNIX epoch.\nThe destination of the transaction.\nConfiguration of the transaction that is being executed.\nThe value sent to <code>transact_to</code>.\nSalt.\nHalting will spend all the gas, and will be equal to …\nAn Ethereum address, 20 bytes in length.\nStack-allocated buffer for efficiently computing address …\nError type for address checksum validation.\n16-byte fixed byte-array type.\n20-byte fixed byte-array type.\n32-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\nNumber of bits to set per input in Ethereum bloom filter.\nSize of the bloom filter in bits\nSize of the bloom filter in bytes.\nThe error type that is returned when conversion to or from …\nA block hash.\nA block number.\nA block timestamp.\nEthereum 256 byte bloom filter.\nInput to the <code>Bloom::accrue</code> method.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nChain identifier type (introduced in EIP-155).\nA transaction that creates a contract.\nExplicit V value. May be EIP-155 modified.\nA byte array of fixed length (<code>[u8; N]</code>).\nError converting from bytes.\nError converting hex to bytes.\nAn Ethereum ABI function pointer, 24 bytes in length.\nAlready hashed input.\nError while decoding hex.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\nError that occurs when the number is too large or too …\nTrait for an object that can be converted into a log data …\nInvalid ERC-55 checksum.\nInvalid parity.\nk256 error\nSimple <code>Keccak-256</code> hasher.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nLess than zero.\nNon-EIP155. 27 or 28.\nThe parity of the signature, stored as either a V value …\nParity flag. True for odd.\nThe error type that is returned when parsing a signed …\nGreater than or equal to zero.\nAn Ethereum ECDSA signature.\nRaw input to be hashed.\nError that occurs when an invalid digit is encountered …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nSolidity contract functions are addressed using the first …\nEnum to represent the sign of a 256-bit signed integer.\nAn Ethereum ECDSA signature.\nErrors in signature parsing or verification.\nSigned integer wrapping a <code>ruint::Uint</code>.\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe <code>to</code> field of a transaction. Either a target address, or …\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n128-bit unsigned integer type, consisting of 2, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nType aliases for common primitive types.\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nThe plain data.\nThe log data.\nHash a message according to EIP-191 (version <code>0x01</code>).\nConverts a sequence of string literals containing …\nCalculate the seal hash, this may be slow.\nMacro for converting sequence of string literals …\nConsume and convert into a <code>LogData</code> object.\nSimple interface to the <code>Keccak-256</code> hash function.\nCompute the logs bloom filter for the given logs.\nRe-exports of map types and utilities.\nAttempts to normalize the v value to a boolean parity …\nApplies EIP-155.\nConvert into a <code>LogData</code> object.\nTries to create a <code>Vec</code> containing the arguments.\nCommon Ethereum utilities.\nWrap a fixed-size byte array in a newtype, delegating all …\n128-byte fixed byte-array type.\n16-byte fixed byte-array type.\n2-byte fixed byte-array type.\n24-byte fixed byte-array type.\n256-byte fixed byte-array type.\n28-byte fixed byte-array type.\n32-byte fixed byte-array type.\n4-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\n1-byte fixed byte-array type.\n12-byte fixed byte-array type.\nA block hash.\nA block number.\nA block timestamp.\nChain identifier type (introduced in EIP-155).\nThe 0-bit signed integer type, capable of representing 0.\nThe 1-bit signed integer type, capable of representing 0 …\n104-bit signed integer type, consisting of 2, 64-bit limbs.\n112-bit signed integer type, consisting of 2, 64-bit limbs.\n120-bit signed integer type, consisting of 2, 64-bit limbs.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n136-bit signed integer type, consisting of 3, 64-bit limbs.\n144-bit signed integer type, consisting of 3, 64-bit limbs.\n152-bit signed integer type, consisting of 3, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n168-bit signed integer type, consisting of 3, 64-bit limbs.\n176-bit signed integer type, consisting of 3, 64-bit limbs.\n184-bit signed integer type, consisting of 3, 64-bit limbs.\n192-bit signed integer type, consisting of 3, 64-bit limbs.\n200-bit signed integer type, consisting of 4, 64-bit limbs.\n208-bit signed integer type, consisting of 4, 64-bit limbs.\n216-bit signed integer type, consisting of 4, 64-bit limbs.\n224-bit signed integer type, consisting of 4, 64-bit limbs.\n232-bit signed integer type, consisting of 4, 64-bit limbs.\n24-bit signed integer type, consisting of 1, 64-bit limbs.\n240-bit signed integer type, consisting of 4, 64-bit limbs.\n248-bit signed integer type, consisting of 4, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n40-bit signed integer type, consisting of 1, 64-bit limbs.\n48-bit signed integer type, consisting of 1, 64-bit limbs.\n512-bit signed integer type, consisting of 8, 64-bit limbs.\n56-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n72-bit signed integer type, consisting of 2, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\n80-bit signed integer type, consisting of 2, 64-bit limbs.\n88-bit signed integer type, consisting of 2, 64-bit limbs.\n96-bit signed integer type, consisting of 2, 64-bit limbs.\nSolidity contract functions are addressed using the first …\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n104-bit unsigned integer type, consisting of 2, 64-bit …\n112-bit unsigned integer type, consisting of 2, 64-bit …\n120-bit unsigned integer type, consisting of 2, 64-bit …\n128-bit unsigned integer type, consisting of 2, 64-bit …\n136-bit unsigned integer type, consisting of 3, 64-bit …\n144-bit unsigned integer type, consisting of 3, 64-bit …\n152-bit unsigned integer type, consisting of 3, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n168-bit unsigned integer type, consisting of 3, 64-bit …\n176-bit unsigned integer type, consisting of 3, 64-bit …\n184-bit unsigned integer type, consisting of 3, 64-bit …\n192-bit unsigned integer type, consisting of 3, 64-bit …\n200-bit unsigned integer type, consisting of 4, 64-bit …\n<code>Uint</code> for <code>2048</code> bits.\n208-bit unsigned integer type, consisting of 4, 64-bit …\n216-bit unsigned integer type, consisting of 4, 64-bit …\n224-bit unsigned integer type, consisting of 4, 64-bit …\n232-bit unsigned integer type, consisting of 4, 64-bit …\n24-bit unsigned integer type, consisting of 1, 64-bit …\n240-bit unsigned integer type, consisting of 4, 64-bit …\n248-bit unsigned integer type, consisting of 4, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n40-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n48-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n56-bit unsigned integer type, consisting of 1, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n72-bit unsigned integer type, consisting of 2, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\n80-bit unsigned integer type, consisting of 2, 64-bit …\n88-bit unsigned integer type, consisting of 2, 64-bit …\n96-bit unsigned integer type, consisting of 2, 64-bit …\n<code>HashMap</code> optimized for hashing <code>Address</code>.\n<code>HashSet</code> optimized for hashing <code>Address</code>.\n<code>HashMap</code> optimized for hashing <code>B256</code>.\n<code>HashSet</code> optimized for hashing <code>B256</code>.\nThe default <code>BuildHasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nThe default <code>Hasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nA view into a single entry in a map, which may either be …\n<code>BuildHasher</code> optimized for hashing fixed-size byte arrays.\n<code>Hasher</code> optimized for hashing fixed-size byte arrays.\n<code>HashMap</code> optimized for hashing fixed-size byte arrays.\n<code>HashSet</code> optimized for hashing fixed-size byte arrays.\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nAn occupied entry.\n<code>HashMap</code> optimized for hashing <code>Selector</code>.\n<code>HashSet</code> optimized for hashing <code>Selector</code>.\nA vacant entry.\nA hash map implemented with quadratic probing and SIMD …\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nThe default <code>Hasher</code> used by <code>RandomState</code>.\nA draining iterator over the entries of a <code>HashMap</code>.\nA view into a single entry in a map, which may either be …\nA draining, filtering iterator over the entries of a …\nA hash map implemented with quadratic probing and SIMD …\nAn owning iterator over the entries of a <code>HashMap</code>.\nAn owning iterator over the keys of a <code>HashMap</code>.\nAn owning iterator over the values of a <code>HashMap</code>.\nAn iterator over the entries of a <code>HashMap</code>.\nA mutable iterator over the entries of a <code>HashMap</code>.\nAn iterator over the keys of a <code>HashMap</code>.\nAn occupied entry.\nAn occupied entry.\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nThe error returned by <code>try_insert</code> when the key already …\n<code>RandomState</code> is the default state for <code>HashMap</code> types.\nA builder for computing where in a HashMap a key-value …\nA builder for computing where in a HashMap a key-value …\nA view into a single entry in a map, which may either be …\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nA vacant entry.\nA vacant entry.\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nAn iterator over the values of a <code>HashMap</code>.\nA mutable iterator over the values of a <code>HashMap</code>.\nThe entry in the map that was already occupied.\nThe value which was not inserted, because the entry was …\nA lazy iterator producing elements in the difference of …\nA draining iterator over the items of a <code>HashSet</code>.\nA view into a single entry in a set, which may either be …\nA draining, filtering iterator over the items of a <code>HashSet</code>.\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nA lazy iterator producing elements in the intersection of …\nAn owning iterator over the items of a <code>HashSet</code>.\nAn iterator over the items of a <code>HashSet</code>.\nAn occupied entry.\nA view into an occupied entry in a <code>HashSet</code>. It is part of …\nA lazy iterator producing elements in the symmetric …\nA lazy iterator producing elements in the union of <code>HashSet</code>…\nA vacant entry.\nA view into a vacant entry in a <code>HashSet</code>. It is part of the …\nError for <code>from_base_le</code> and <code>from_base_be</code>.\nError from <code>Uint::from_base_be</code>.\nA newtype wrapper around <code>Uint</code> that restricts operations to …\nError for <code>TryFrom&lt;Uint&gt;</code>.\nThe requested number base <code>.0</code> is less than two.\nThe provided digit <code>.0</code> is out of range for requested base <code>.1</code>…\nInvalid digit in string.\nInvalid radix, up to base 64 is supported.\n‘Not a number’ (NaN) can not be represented as Uint\nNumber is equal or larger than the target field modulus.\nThe value is too large to fit the target type.\nThe Uint value is too large for the target type.\nError for <code>from_str_radix</code>.\nError for <code>TryFrom&lt;Uint&gt;</code> for <code>ark_ff</code> and others.\nError for <code>TryFrom&lt;T&gt;</code> for <code>Uint</code>.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\nNegative values can not be represented as Uint.\nValue is too large to fit the Uint.\n⚠️ Collection of bignum algorithms.\nType aliases for common bit sizes of <code>Uint</code> and <code>Bits</code>.\nCompile time for loops with a <code>const</code> variable for testing.\nMask to apply to the highest limb to get the correct …\nNumber of bytes required to represent the given number of …\nNumber of <code>u64</code> limbs required to represent the given number …\nSupport for external crates.\n⚠️ Lehmer update matrix\n<code>lhs += rhs + carry</code>\nComputes <code>lhs += a</code> and returns the carry.\n⚠️ Computes <code>result += a * b</code> and checks for overflow.\nComputes wrapping <code>lhs += a * b</code> when all arguments are the …\nComputes <code>lhs += a * b</code> and returns the carry.\nCompare two <code>u64</code> slices in reverse order.\n⚠️ Collection of division algorithms.\n⚠️ Division with remainder.\n⚠️ Lehmer’s GCD algorithms.\n⚠️ Lehmer’s extended GCD.\n⚠️ Modular inversion using extended GCD.\nComputes <code>lhs *= a</code> and returns the carry.\nComputes a * b * 2^(-BITS) mod modulus\n<code>lhs -= rhs - borrow</code>\nComputes a^2 * 2^(-BITS) mod modulus\nComputes <code>lhs -= a * b</code> and returns the borrow.\n⚠️ Division with remainder.\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient of a 192 bits divided by a …\n⚠️ Computes the quotient of a 192 bits divided by a …\nTODO: This implementation is off by one.\n⚠️ Compute single limb division.\n⚠️ Compute single limb normalized division.\n⚠️ Compute double limb division.\n⚠️ Compute double limb normalized division.\n⚠️ In-place Knuth long division with implicit …\n⚠️ In-place Knuth normalized long division with …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathtt{d}}} - …\n<code>Bits</code> for <code>0</code> bits.\n<code>Bits</code> for <code>1</code> bits.\n<code>Bits</code> for <code>1024</code> bits.\n<code>Bits</code> for <code>128</code> bits.\n<code>Bits</code> for <code>16</code> bits.\n<code>Bits</code> for <code>160</code> bits.\n<code>Bits</code> for <code>192</code> bits.\n<code>Bits</code> for <code>2048</code> bits.\n<code>Bits</code> for <code>256</code> bits.\n<code>Bits</code> for <code>32</code> bits.\n<code>Bits</code> for <code>320</code> bits.\n<code>Bits</code> for <code>384</code> bits.\n<code>Bits</code> for <code>4096</code> bits.\n<code>Bits</code> for <code>448</code> bits.\n<code>Bits</code> for <code>512</code> bits.\n<code>Bits</code> for <code>64</code> bits.\n<code>Bits</code> for <code>768</code> bits.\n<code>Bits</code> for <code>8</code> bits.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n<code>Uint</code> for <code>128</code> bits. Similar to <code>u128</code>.\n<code>Uint</code> for <code>16</code> bits. Similar to <code>u16</code>.\n<code>Uint</code> for <code>160</code> bits.\n<code>Uint</code> for <code>192</code> bits.\n<code>Uint</code> for <code>2048</code> bits.\n<code>Uint</code> for <code>256</code> bits.\n<code>Uint</code> for <code>32</code> bits. Similar to <code>u32</code>.\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n<code>Uint</code> for <code>512</code> bits.\n<code>Uint</code> for <code>64</code> bits. Similar to <code>u64</code>.\n<code>Uint</code> for <code>768</code> bits.\n<code>Uint</code> for <code>8</code> bits. Similar to <code>u8</code>.\nThe prefix used for hashing messages according to EIP-191.\nSigned 256-bit integer.\nThe provided units are not recognized.\nSimple <code>Keccak-256</code> hasher.\nOverflow when parsing a signed number.\nThis enum holds the numeric types that a possible to be …\nUnsigned 256-bit integer.\nEthereum unit. Always less than <code>77</code>.\nError type for <code>Unit</code>-related operations.\nAllocates memory on the heap then places <code>x</code> into it, …\nConstructs a new box with uninitialized contents on the …\nHash a message according to EIP-191 (version <code>0x01</code>).\nConstructs a message according to EIP-191 (version <code>0x01</code>).\nFormats the given number of Wei as an Ether amount.\nFormats the given number of Wei as the given unit.\nSimple interface to the <code>Keccak-256</code> hash function.\nConverts the input to a U256 and converts from Ether to …\nParses a decimal number and multiplies it with 10^units.\nTries to collect the elements of an iterator into a <code>Vec</code>.\nTries to create a <code>Vec</code> with the given capacity.\nBit-Array Type Definition\nMemory Bus Access Management\nStatically-Allocated, Fixed-Size, Bit Buffer\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nHeap-Allocated, Fixed-Size, Bit Buffer\nMemory Region Description\nBit-Field Memory Slots\nBit Indices\nConstructor Macros\nMemory Element Descriptions\nIn-Element Bit Ordering\nSymbol Export\nRaw Pointer Implementation\nBit-Addressable Memory Regions\nStorage Memory Description\nDynamically-Allocated, Adjustable-Size, Bit Buffer\nBit View Adapters\nBit-Level Access Instructions\nRead-Only Semivolatile Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nRead-Only Shared-Mutable Handle\nThe element type being guarded against improper mutation.\nThe memory-access type this guards.\nThe zero constant.\nLoads the value from memory, allowing for the possibility …\nBit-Precision Array Immediate\nBit-Array Iteration\nThe ordering of bits within an <code>A::Store</code> element.\nThe wrapped data buffer.\nFixed-Size, Heap-Allocated, Bit Slice\nAn iterator over a <code>BitBox</code>.\nBit-Slice Partitioning\nBit-Slice Element Partitioning\nIndicates that a bit-slice’s contents are entirely in …\nIndicates that a bit-slice’s contents are entirely in …\nPartially-Owned Memory Element\nIndicates that a bit-slice’s contents touch an element …\nIndicates that a bit-slice’s contents touch an element …\nAny bits that wholly-fill elements in the interior of the …\nAny bits that partially-fill the first element of the …\nAny bits that partially-fill the last element of the …\nAll fully-used elements in the bit-slice’s underlying …\nThe first element in the bit-slice’s underlying storage, …\nThe last element in the bit-slice’s underlying storage, …\nC-Style Bit-Field Access\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nOne-Bit-After Tail Index\nSemantic Bit Index\nBit Index Error\nMulti-Bit Selection Mask\nBit Position\nOne-Hot Bit Selection Mask\nThe literal <code>!0</code>.\nRegister Descriptions\nCounts the number of bits in a value of type <code>T</code>.\nBit Storage Calculator\nIn-Element Bit Ordering\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nMost-Significant-First Bit Traversal\nTranslates a semantic bit index into a real bit position.\nComplete <code>BitOrder</code> Verification\nSingle-Type <code>BitOrder</code> Verification\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nImmutable Bit View\nMutable Bit View\nBit-Array Type Definition\nBit-Precision Array Immediate\nFixed-Size, Heap-Allocated, Bit Slice\nIn-Element Bit Ordering\nSingle-Bit Pointer\nBit-Pointer Range\nProxy Bit-Reference\nBit-Addressable Memory\nBit Storage\nBit-Precision Dynamic Array\nLeast-Significant-First Bit Traversal\nLeast-Significant-First Bit Traversal\nThe element type used in the memory region underlying a …\nMost-Significant-First Bit Traversal\nThe underlying element type.\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nThe zero constant.\nBit View\nC-Style Bit-Field Access\nHelper trait for scalars and arrays, but not slices.\nThe ordering of bits within an <code>A::Store</code> element.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nTranslates a semantic bit index into a real bit position.\nBit-Array Value Constructor\nBoxed Bit-Slice Constructor\nBit-Slice Region Constructor\nBit-Vector Constructor\nThe wrapped data buffer.\nThe higher, exclusive, bound of the range. The bit to …\nBig-Endian Integer Loading\nLittle-Endian Integer Loading\nLoads a value out of the memory system according to the …\nWraps a raw memory value as a <code>BitStore</code> type.\nThe lower, inclusive, bound of the range. The bit to which …\nBig-Endian Integer Storing\nLittle-Endian Integer Storing\nStores a value into the memory system. This is only called …\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nSingle-Bit Pointer\nErrors produced by invalid bit-pointer components.\nBit-Pointer Range\nProxy Bit-Reference\nAn error produced when creating <code>BitSpan</code> encoded references.\nA basic <code>const</code> marker.\nThe error produced when an address is insufficiently …\nAttempted to construct a bit-pointer with an address not …\nThe base element pointer is not aligned.\nA basic <code>mut</code> marker.\nGeneralized mutability permissions.\nAttempted to construct a bit-pointer with the null element …\nA null pointer was provided.\nOne of <code>*const</code> or <code>*mut</code>.\nAllow instances to be constructed generically.\nThe requested address is too high, and wraps to zero.\nThe requested length exceeds the <code>BitSpan</code> length ceiling.\nBit-Slice Pointer Construction\nBit-Slice Pointer Construction\nEnsures that an address is well-aligned to its referent …\nBit-wise <code>memcpy</code>\nBit-wise <code>memcpy</code>\nRemote Destructor\nThe higher, exclusive, bound of the range. The bit to …\nBit-Pointer Equality\nBit-Pointer Hashing\nBit-Pointer Sentinel Value\nBit-Pointer Sentinel Value\nSingle-Bit Read\nSingle-Bit Unaligned Read\nSingle-Bit Volatile Read\nSingle-Bit Replacement\nRaw Bit-Slice Pointer Construction\nRaw Bit-Slice Pointer Construction\nThe lower, inclusive, bound of the range. The bit to which …\nBit Swap\nMany-Bit Swap\nSingle-Bit Write\nBit-wise <code>memset</code>\nBit-wise <code>memset</code>\nSingle-Bit Unaligned Write\nSingle-Bit Volatile Write\nAn iterator over <code>BitSlice</code> that yields <code>&amp;bool</code> directly.\nBit-Addressable Memory\nBit-Slice Indexing\nAn iterator over <code>BitSlice</code> that yields <code>bool</code> directly.\nShared Bit-Slice Chunking\nShared Bit-Slice Exact Chunking\nExclusive Bit-Slice Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nThe output type of immutable access.\nShared Bit-Slice Iteration\nExclusive Bit-Slice Iteration\nAnti-Aliasing Iterator Adapter\nBit Seeking\nBit Seeking\nThe output type of mutable access.\nShared Bit-Slice Reverse Chunking\nShared Bit-Slice Reverse Exact Chunking\nExclusive Bit-Slice Reverse Exact Chunking\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Chunking\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Reverse Splitting\nExclusive Bit-Slice Reverse Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nShared Bit-Slice Splitting\nExclusive Bit-Slice Splitting\nAnti-Aliasing Iterator Adapter\nBit-Slice Windowing\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nRaw Bit-Slice Construction\nImmutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nMutably indexes into a bit-slice, returning <code>None</code> if <code>self</code> …\nImmutably indexes into a bit-slice without doing any …\nMutably indexes into a bit-slice without doing any bounds …\nImmutably indexes into a bit-slice, panicking if <code>self</code> is …\nMutably indexes into a bit-slice, panicking if <code>self</code> is out …\nAll implementors are required to have <code>Self</code> and <code>Self::Alias</code> …\nAll implementors are required to have their alignment …\nA type that selects the appropriate load/store …\nA sibling <code>BitStore</code> implementor that is known to be …\nBit Storage\nThe element type used in the memory region underlying a …\nThe inverse of <code>::Alias</code>. It is used when a <code>BitSlice</code> removes …\nThe zero constant.\nLoads a value out of the memory system according to the …\nWraps a raw memory value as a <code>BitStore</code> type.\nStores a value into the memory system. This is only called …\nBit-Precision Dynamic Array\nDraining Iteration\nAn iterator over a <code>BitBox</code>.\nSplicing Iteration\nImmutable Bit View\nMutable Bit View\nBit View\nHelper trait for scalars and arrays, but not slices.\nThe underlying element type.\nThe zero constant.\nViews <code>self</code> as an immutable bit-slice region with the <code>O</code> …\nViews <code>self</code> as a mutable bit-slice region with the <code>O</code> …\nViews the type as a mutable slice of its elements.\nViews the type as a slice of its elements.\nAttempts to view <code>self</code> as an immutable bit-slice region …\nAttempts to view <code>self</code> as a mutable bit-slice region with …\nAttempts to view a memory region as an immutable bit-slice.\nAttempts to view a memory region as a mutable bit-slice.\nViews a memory region as an immutable bit-slice.\nViews a memory region as a mutable bit-slice.\nEVM database interface.\nEVM database commit interface.\nEVM database interface.\nThe database error type.\nThe database error type.\nWraps a <code>DatabaseRef</code> to provide a <code>Database</code> implementation.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet basic account information.\nGet block hash by block number\nGet block hash by block number\nGet block hash by block number.\nGet block hash by block number.\nGet account code by its hash\nGet account code by its hash\nGet account code by its hash.\nGet account code by its hash.\nCommit changes to the database.\nDatabase that is split on State and BlockHash traits.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet storage value of address at index.\nGet basic account information.\nGet basic account information.\nBlockHash database component from <code>crate::db::Database</code> it …\nGet block hash by block number\nGet block hash by block number\nGet account code by its hash\nGet account code by its hash\nState database component from <code>crate::db::Database</code> it is …\nGet storage value of address at index.\nGet storage value of address at index.\nGet block hash by block number\nGet block hash by block number\nGet basic account information.\nGet basic account information.\nGet account code by its hash\nGet account code by its hash\nGet storage value of address at index.\nGet storage value of address at index.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nIndicates a failed recovery attempt where no valid address …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nCost of creating authorized account that was previously …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nOnly supported version is version 0x00.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nIndicates a failed recovery attempt where no valid address …\nAn Ethereum ECDSA signature.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nIndicates a successfully recovered authority address.\nThe address of the authorization.\nThe chain ID of the authorization.\nThe nonce for the authorization.\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEIP-7702 first version of bytecode.\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nOnly supported version is version 0x00.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nStructure holding block blob excess gas and it calculates …\nThe block environment.\nA transaction that calls a contract or transfer.\nEVM configuration.\nConfiguration environment with the chain spec id.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nCreate scheme of <code>CREATE2</code>.\nCreate scheme.\nEVM environment configuration.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nDo not perform bytecode analysis.\nTransaction destination\nThe transaction environment.\nA list of addresses and storage keys that the transaction …\nList of authorizations, that contains the signature that …\nThe base fee per gas, added in the London upgrade with …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\nCoinbase or miner or address that created and signed the …\nThe data of the transaction.\nThe difficulty of the block.\nEvm environment.\nThe excess blob gas of the block.\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nHandler configuration fields.\nHandler configuration fields.\nKZG Settings for point evaluation precompile. By default, …\nIf some it will effects EIP-170: Contract code size limit. …\nThe max fee per blob gas.\nThe nonce of the transaction.\nThe number of ancestor blocks of this block (block height).\nBytecode that is created with CREATE/CREATE2 is by default …\nThe output of the randomness beacon provided by the beacon …\nSpecification identification.\nThe timestamp of the block in seconds since the UNIX epoch.\nThe destination of the transaction.\nConfiguration of the transaction that is being executed.\nThe value sent to <code>transact_to</code>.\nSalt.\nConfiguration environment with the chain spec id.\nEvm environment with the chain spec id.\nHandler configuration fields. It is used to configure the …\nConfiguration environment.\nEvm environment.\nHandler configuration fields.\nHandler configuration fields.\nSpecification identification.\nBody size is more than specified in the header.\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nEVM Object Format (EOF) container.\nEOF container body.\nEOF decode errors.\nEOF Header containing\nInvalid number for code kind\nInvalid data kind\nInvalid EOF magic number.\nInvalid initcode size.\nInvalid EOF version.\nInvalid kind after code\nInvalid terminal code\nInvalid number for types kind\nInvalid types section data.\nInvalid types section size.\nMismatch of code and types sizes.\nShort body while processing EOF.\nShort input while processing EOF.\nThere should be at least one size.\nMissing size.\nInvalid code number.\nInvalid container number.\nTypes section that contains stack information for matching …\nInvalid number of code sections.\nSize cant be zero\nSizes of EOF code section. Code size can’t be zero.\nEOF Container size. Container size can be zero.\nEOF data size.\ninputs - 1 byte - <code>0x00-0x7F</code> number of stack elements the …\nmax_stack_height - 2 bytes - <code>0x0000-0x03FF</code> maximum number …\noutputs - 1 byte - <code>0x00-0x80</code> number of stack elements the …\nsum code sizes\nsum container sizes\nSize of EOF types section. types section includes num of …\nCustom trusted setup.\nDefault mainnet trusted setup\nKZG Settings that allow us to specify a custom trusted …\nStores the setup and parameters needed for computing KZG …\nA map of valid <code>jump</code> destinations.\nLegacy analyzed\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nSimilar to Standard but takes reference to environment.\nContains the error value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nPrecompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nOutput bytes.\nGas used by the precompile.\nAccess list is not supported for blocks before the Berlin …\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\nBlob transaction can’t be a create transaction. <code>to</code> must …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCustom error.\nDatabase error.\nEOF Subroutine stack overflow\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHeader validation error.\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nTransaction validation error.\nTransaction account does not have enough amount of ether …\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nOutput of a transaction execution.\nOverflow payment in transaction.\nPrecompile error.\n<code>prevrandao</code> is not set for Merge and above.\nWhen using the EIP-1559 fee model introduced in the London …\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nTransaction validation error.\nStatus of execution\nState that got updated\nHalting will spend all the gas, and will be equal to …\nThe specification ID.\nSpecification IDs and their activation block.\nAccountInfo account information.\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\nStructure used for EIP-1153 transient storage.\nAccount balance.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\ncode hash,\nBalance, nonce, and code.\nRepresents if the storage slot is cold.\nAccount nonce.\nOriginal value of the storage slot.\nPresent value of the storage slot.\nAccount status flags.\nStorage cache\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nSimple interface to the <code>Keccak-256</code> hash function.\nConverts a boolean to a left-padded <code>B256</code> value.\nConverts a boolean to a left-padded 32-byte <code>Bytes</code> value.\nLeft-pads the given slice with zeroes until <code>LEN</code>.\nLeft-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice with zeroes until <code>LEN</code>.\nRight-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>LEN</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>len</code>.\nAccessList as defined in EIP-2930\nA list of addresses and storage keys that the transaction …\nAccess list is not supported for blocks before the Berlin …\nAccountInfo account information.\nAn Ethereum address, 20 bytes in length.\nPerform bytecode analysis.\nWhat bytecode analysis to perform.\nAn unsigned EIP-7702 authorization.\nAuthorization list for EIP-7702 transaction type.\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\n32-byte fixed byte-array type.\nControls the maximum rate of change for blob gas price.\nControls the maximum rate of change for blob gas price …\nEIP-2935: Serve historical block hashes from state\nEIP-2935: Serve historical block hashes from state\nNumber of block hashes that EVM can access in the past …\nBlob transaction can’t be a create transaction. <code>to</code> must …\nStructure holding block blob excess gas and it calculates …\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nThe block environment.\nState of the <code>Bytecode</code> analysis.\nEOF decode errors.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nA transaction that calls a contract or transfer.\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nEVM configuration.\nConfiguration environment with the chain spec id.\nused to mark account as cold\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>.\nA transaction that creates a contract.\nCreate scheme of <code>CREATE2</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCreate scheme.\nWhen account is newly created we will not access database …\nCustom trusted setup.\nCustom error.\nDatabase error.\nDefault mainnet trusted setup\nEIP-7702 Version Magic in u16 form.\nEIP-7702 magic number in array form.\nHash of EF01 bytes that is used for EXTCODEHASH when …\nEOF Subroutine stack overflow\nEOF Magic in u16 form.\nEOF magic number in array form.\nHash of EF00 bytes that is used for EXTCODEHASH when …\nMain EVM error.\nResult of EVM execution.\nGeneric result of EVM execution. Used to represent error …\nEIP-7702 delegated bytecode\nEIP-7702 decode error\nBytecode of delegated account, specified in EIP-7702\nBytecode errors.\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nEVM environment configuration.\nSimilar to Standard but takes reference to environment.\nKZG Settings that allow us to specify a custom trusted …\nEvm environment with the chain spec id.\nEVM Object Format (EOF) container.\nEthereum Object Format\nEOF decode error\nAux data overflow, new aux data is larger than u16 max …\nAud data is smaller then already present data size.\nEOF crate should have <code>to</code> address\nContains the error value\nContains the error value\nContains the error value\nEVM State is a mapping from addresses to accounts.\nAn account’s Storage is a mapping from 256-bit integer …\nThis type keeps track of the current value of a storage …\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution.\nA byte array of fixed length (<code>[u8; N]</code>).\nGas consumption of a single data blob (== blob byte size).\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas.\nIndicates that the EVM has experienced an exceptional …\nHandler configuration fields. It is used to configure the …\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nHeader validation error.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\nIndicates a failed recovery attempt where no valid address …\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a …\nInvalid length of the raw bytecode. It should be 23 bytes.\nAll Eip7702 bytecodes should start with the magic number …\nTransaction validation error.\nA map of valid <code>jump</code> destinations.\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nStores the setup and parameters needed for computing KZG …\nTransaction account does not have enough amount of ether …\nThe bytecode has been analyzed for valid jump destinations.\nLegacy analyzed\nNo analysis has been performed.\nWhen account is loaded but not touched or interacted with. …\nused only for pre spurious dragon hardforks where existing …\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nEIP-170: Contract code size limit\nEIP-3860: Limit and meter initcode\nMinimum gas price for data blobs.\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nContains the success value\nContains the success value\nContains the success value\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nOutput of a transaction execution.\nOverflow payment in transaction.\nThe address of precompile 3, which is handled specially in …\nPrecompile and its handlers.\nPrecompile error.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\n<code>prevrandao</code> is not set for Merge and above.\nAn Ethereum ECDSA signature.\nWhen using the EIP-1559 fee model introduced in the London …\nDo not perform bytecode analysis.\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas.\nThe specification ID.\nIf account is marked for self destruction.\nA signed EIP-7702 authorization.\nSpecification IDs and their activation block.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max_blob_num_per_block</code> blobs.\nOnly when account is marked as touched we will save it to …\nTransaction destination\nTransaction validation error.\nStructure used for EIP-1153 transient storage.\nThe transaction environment.\nThe <code>to</code> field of a transaction. Either a target address, or …\n256-bit unsigned integer type, consisting of 4, 64-bit …\nOnly supported version is version 0x00.\nFirst version of the blob.\nIndicates a successfully recovered authority address.\nArray of Zero bytes.\nArray of Zero bytes.\nA list of addresses and storage keys that the transaction …\nAdds an address to the access list and returns <code>true</code> if the …\nReturns an optional address if valid.\nGet the <code>address</code> for the authorization.\nReturn the address of the delegated contract.\nReturns the created address, if any.\nAccount addresses that would be loaded at the start of …\nThe address of the authorization.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nGet a flags value with all known bits set.\nReturns the byte-array representation of this signature.\nReturns the ERC-2098 compact representation of this …\nReturns a mutable slice containing the entire array. …\nGet the raw bytes of the jump map\nReturns a slice containing the entire array. Equivalent to …\nReturns an optional address based on the current state of …\nList of authorizations, that contains the signature that …\nConverts a sequence of string literals containing …\nAccount balance.\nThe base fee per gas, added in the London upgrade with …\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nExcess blob gas and blob gasprice. See also …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>…\nThe list of blob versioned hashes. Per EIP there should be …\nReturns the blob target and max count for the given spec …\nBlob target count. EIP-7840 Add blob schedule to EL config …\nConfiguration of the block the transaction is in.\nCreate boxed Env.\nReturns a reference to the bytecode.\nReturns a reference to the bytecode.\nReturns bytes\nOutput bytes.\nConverts a sequence of string literals containing …\nReturns bytes slice\nCalculates the blob gas price from the header’s excess …\nCalculates the EIP-4844 <code>data_fee</code> of the transaction.\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nCalculates the maximum [EIP-4844] <code>data_fee</code> of the …\nCall the precompile with the given input and gas limit and …\nCall the precompile with the given input and gas limit and …\nCaller aka Author aka transaction signer.\nConfiguration of the EVM itself.\nConfiguration environment.\nGet the <code>chain_id</code> for the authorization.\nThe chain ID of the authorization.\nChain ID of the EVM, it will be compared to the transaction…\nThe chain ID of the transaction. If set to <code>None</code>, no checks …\nReturns an iterator over the storage slots that have been …\nResets environment to default values.\nClears environment and resets fields to default values.\nClears environment and resets fields to default values.\ncode: if None, <code>code_by_hash</code> will be used to fetch it if …\nReturn bytecode hash associated with this account. If …\ncode hash,\nCoinbase or miner or address that created and signed the …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nConcatenate two <code>FixedBytes</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nReturns <code>true</code> if no bits are set.\nWhether all set bits in a source flags value are also set …\nChecks if the access list contains the specified address.\nChecks if a specific storage slot within an account is …\nCreates a new <code>Bytes</code> instance from a slice by copying it.\nReturns a copy of this account with the <code>Bytecode</code> removed. …\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nComputes the <code>create</code> address for this address and nonce:\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the <code>CREATE2</code> address of a smart contract as …\nReturns a slice of the data section.\nReturns the output data of the execution output.\nThe data of the transaction.\nThe plain data.\nThe log data.\nReturns a slice of the raw bytes. If offset is greater …\nDecode EOF from raw bytes.\nDecode EOF that have additional dangling bytes. Assume …\nDecode an RLP-encoded VRS signature. Accepts <code>decode_parity</code> …\nThe intersection of a source flags value with the …\nThe difficulty of the block.\nCalculates the effective gas price of the transaction.\nReturn empty authorization list.\nCreates a new empty log.\nCreates a new empty log.\nGet a flags value with all bits unset.\nReturns <code>true</code> if the given specification ID is enabled in …\nReturns <code>true</code> if the given specification ID is enabled in …\nReturns <code>true</code> if the given specification ID is enabled in …\nReturns <code>true</code> if the given specification ID is enabled in …\nSlow encode EOF bytes.\nEvm environment.\nReturn reference to the EOF if bytecode is EOF.\nThe excess blob gas of the block.\nReturns <code>true</code> if the account is not empty.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nConverts a sequence of string literals containing …\nReturns an iterator over the list’s addresses and …\nConverts the list into a vec, expected by revm\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nReturns the argument unchanged.\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>TxKind::Call</code> with the given address.\nCreates a <code>TxKind::Call</code> with the <code>Some</code> address, <code>None</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nParses a signature from a byte slice, with a v value\nDecode the signature from the ERC-2098 compact …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCalculate this block excess gas and price from the parent …\nConverts an ECDSA signing key to its corresponding …\nConverts an ECDSA verifying key to its corresponding …\nParses a 65-byte long raw signature.\nParses a 65-byte long raw signature.\nInstantiate by hashing public key bytes.\nCreates a <code>PrimitiveSignature</code> from the serialized <code>r</code> and <code>s</code> …\nInstantiate from a signature and recovery id\nConstruct a jump map from raw bytes\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>.\nCreates a new <code>Bytes</code> from a static slice.\nCreates an Ethereum address from an EVM word’s upper 20 …\nThe gas limit of the block.\nThe gas limit of the transaction.\nThe gas price of the transaction.\nThe priority fee per gas.\nReturns the gas used.\nGas used by the precompile.\nReturn set KZG settings.\nReturn <code>blob_excess_gas</code> header field. See EIP-4844.\nSee EIP-4844 and <code>crate::calc_blob_gasprice</code>.\nSee EIP-4844, <code>Env::calc_data_fee</code>, and …\nHandler configuration fields.\nHandler configuration fields.\nReturns <code>true</code> if account has no nonce and code.\nCalculate hash of the bytecode.\nMacro for converting sequence of string literals …\nBalance, nonce, and code.\nReturns the inner <code>Authorization</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner bytes array.\nReturns the output data of the execution output.\nConsumes the type and returns an iterator over the list’…\nConsumes the type and converts the list into a vec, …\nReturns the inner ECDSA signature.\nConsumes <code>self</code> and returns the logs if execution is …\nConsumes the type and returns the output data of the …\nSplits the authorization into parts.\nRecover the authority and transform the signed …\nReturns recovered authorizations list.\nConvert to a signed authorization by adding a signature.\nConsumes the type and returns the address of the contract …\nLeft-pads the address to 32 bytes (EVM word size).\nWhether all known bits in this flags value are set.\nReturns true if the transaction is a contract call.\nReturns true if the present value differs from the …\nRepresents if the storage slot is cold.\nReturns true if the transaction is a contract creation.\nIs account newly created in this transaction.\nReturns true if bytecode is EIP-7702.\nReturns whether the bytecode is empty.\nReturns true if the authorization list is empty.\nIs account empty, check if nonce and balance are zero and …\nWhether all bits in this flags value are unset.\nReturns if an account is empty.\nReturns true if the code hash is the Keccak256 hash of the …\nReturns <code>true</code> if the given specification ID is enabled in …\nReturns true if bytecode is EOF.\nReturns false if bytecode can’t be executed in …\nReturns true if execution result is a Halt.\nReturns true if the authority is invalid.\nIs account loaded as not existing from database This is …\nReturns true if the error is out of gas.\nReturns <code>true</code> if the optimism feature is enabled and flag …\nIs account marked for self destruct.\nReturns if transaction execution is successful. 1 …\nIf account status is marked as touched.\nReturns true if the authority is valid.\nCheck if <code>pc</code> is a valid jump destination.\nTrue if valid, false otherwise.\nReturns <code>true</code> if no bits are set.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nJumptable of analyzed bytes.\nSimple interface to the <code>Keccak-256</code> hash function.\nKZG Settings for point evaluation precompile. By default, …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nReturn jump table if bytecode is analyzed\nReturns the length of the original bytes.\nReturns length of the authorization list.\nReturns the size of this array in bytes.\nReturns the size of this byte array (<code>N</code>).\nIf some it will effects EIP-170: Contract code size limit. …\nInitializes a trusted setup from <code>FIELD_ELEMENTS_PER_BLOB</code> …\nLoads the trusted setup parameters from a file. The file …\nLoads the trusted setup parameters from a file.\nReturns the logs if execution is successful, or an empty …\nMaps a <code>DBError</code> to a new error type using the provided …\nMark account as cold.\nMarks the storage slot as cold.\nMark account as newly created.\nMark account as self destructed.\nMark account as touched\nMark account as warm and return true if it was previously …\nMarks the storage slot as warm and returns a bool …\nReturns max code size from <code>Self::limit_contract_code_size</code> …\nThe max fee per blob gas.\nCreates a new EOF container from the given body.\nCreate new analyzed bytecode.\nCreates a new EIP-7702 bytecode with the given address.\nCreates new <code>HandlerCfg</code> instance.\nReturns new instance of <code>CfgEnvWithHandlerCfg</code> with the …\nReturns new <code>EnvWithHandlerCfg</code> instance.\nWraps the given byte array in this type.\nCreates a new instance by calculating the blob gas price …\nReturns new precompile output with the given gas used and …\nWraps the given byte array in <code>FixedBytes</code>.\nCreates a new empty <code>Bytes</code>.\nCreates a new log.\nCreates a new log.\nInstantiate a new signature from <code>r</code>, <code>s</code>, and <code>v</code> values.\nCreates a new <em>unchanged</em> <code>EvmStorageSlot</code> for the given value.\nCreate new checked bytecode.\nCreates a new <em>changed</em> <code>EvmStorageSlot</code>.\nCreates a new EIP-7702 <code>Bytecode</code> from <code>Address</code>.\nCreates a new log from an deserialized event.\nCreates a new log.\nCreates a new legacy <code>Bytecode</code>.\nCreate new account and mark it as non existing.\nCreates a new raw <code>Bytecode</code>.\nCreates a new EIP-7702 bytecode or returns None if the raw …\nCreates a new raw <code>Bytecode</code>.\nCreate a new stateful precompile.\nCreate a new mutable stateful precompile.\nCreates a new signed authorization from raw signature …\nInstantiate without performing recovery. This should be …\nCreates a new log, without length-checking. This allows …\nCreates a new log.\nTakes <code>CfgEnvWithHandlerCfg</code> and returns new …\nReturns new <code>CfgEnvWithHandlerCfg</code> instance with the chain …\nReturns new <code>EnvWithHandlerCfg</code> instance with the chain spec …\nGet the <code>nonce</code> for the authorization.\nThe nonce for the authorization.\nThe nonce of the transaction.\nAccount nonce.\nNormalizes the signature into “low S” form as …\nNormalizes the signature into “low S” form as …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe number of ancestor blocks of this block (block height).\nOriginal bytes without padding.\nReturns the original bytecode as a byte slice.\nOriginal bytes without padding.\nReturns a reference to the original bytecode.\nOriginal bytes length.\nReturns the original value of the storage slot.\nOriginal value of the storage slot.\nReturns an other error with the given message.\nReturns the output data of the execution.\nParse an Ethereum address, verifying its EIP-55 checksum.\nParses the contents of a KZG trusted setup file into a …\nBytecode that is created with CREATE/CREATE2 is by default …\nReturns the current value of the storage slot.\nPresent value of the storage slot.\nThe output of the randomness beacon provided by the beacon …\nReturns the signature <code>r</code> value.\nReturns the <code>r</code> component of this signature.\nReturn raw EOF bytes.\nReturn the raw bytecode with version MAGIC number.\nReturns the recovery ID.\nRecovers an <code>Address</code> from this signature and the given …\nRecovers an <code>Address</code> from this signature and the given …\nRecover the authority for the authorization.\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nReturns iterator of recovered Authorizations.\nThe intersection of a source flags value with the …\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new <code>FixedBytes</code> where all bytes are set to <code>byte</code>.\nReserialize the data.\nStatus of execution\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nLength of RLP RS field encoding\nReturns the signature <code>s</code> value.\nReturns the <code>s</code> component of this signature.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nTakes <code>blob_excess_gas</code> saves it inside env and calculates …\nSets the blob target and max count over hardforks.\nSet the topic list, truncating to 4 topics.\nSet the topic list, without length-checking. This allows …\nGets the <code>signature</code> for the authorization. Returns …\nComputes the signature hash used to sign the …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nReturns len of the header and body in bytes.\nCalculates a heuristic for the in-memory size of this …\nReturns a slice of self for the provided range.\nReturns a slice of self that is equivalent to the given …\nReturns the specification id.\nSpecification identification.\nConsumes the log data, returning the topic list and the …\nSplits the bytes into two at the given index.\nSplits the bytes into two at the given index.\nState that got updated\nCheck if account is empty and check if empty state before …\nAccount status flags.\nStorage cache\nKeys of storage that would be loaded at the start of …\nReturns the inner <code>Authorization</code>.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTake bytecode from account. Code will be set to None.\nThe timestamp of the block in seconds since the UNIX epoch.\nReturns the address of the contract that will be called or …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into …\nReturns the inner ECDSA signature.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nGet the topic list.\nGet the topic list, mutably. This gives access to the …\nGet a mutable reference to the topic list. This allows …\nThe destination of the transaction.\nParses a 65-byte long raw signature.\nReturns the <code>SpecId</code> for the given <code>u8</code>.\nConfiguration of the transaction that is being executed.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nUnmark created flag.\nUnmark account as self destructed.\nUnmark the touch flag.\nReturns the recovery ID as a <code>bool</code>.\nValidate the block environment.\nValidate transaction data that is set inside ENV and …\nValidate transaction against state.\nThe value sent to <code>transact_to</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new <code>FixedBytes</code> with the last byte set to <code>x</code>.\nSets the recovery ID by normalizing a <code>v</code> value.\nStrip the <code>Bytecode</code> from this account and drop it. This is …\nWrite R and S to an RLP buffer in progress.\nWrite the VRS to the output.\nReturns the signature parity value.\nSalt.\nHalting will spend all the gas, and will be equal to …\nAn Ethereum address, 20 bytes in length.\nStack-allocated buffer for efficiently computing address …\nError type for address checksum validation.\n16-byte fixed byte-array type.\n20-byte fixed byte-array type.\n32-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\nThe size of this integer type in bits.\nNumber of bits.\nNumber of bits to set per input in Ethereum bloom filter.\nSize of the bloom filter in bits\nSize of the bloom filter in bytes.\nThe size of this integer type in bytes. Note that some …\nThe size of this integer type in bytes. Note that some …\nThe error type that is returned when conversion to or from …\nA block hash.\nA block number.\nA block timestamp.\nEthereum 256 byte bloom filter.\nInput to the <code>Bloom::accrue</code> method.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nChain identifier type (introduced in EIP-155).\nA transaction that creates a contract.\nExplicit V value. May be EIP-155 modified.\nA byte array of fixed length (<code>[u8; N]</code>).\nError converting from bytes.\nError converting hex to bytes.\nAn Ethereum ABI function pointer, 24 bytes in length.\nAlready hashed input.\nError while decoding hex.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\nError that occurs when the number is too large or too …\nTrait for an object that can be converted into a log data …\nInvalid ERC-55 checksum.\nInvalid parity.\nk256 error\nSimple <code>Keccak-256</code> hasher.\nThe size of this integer type in 64-bit limbs.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nBit mask for the last limb.\nThe largest value that can be represented by this integer …\nThe maximum value.\nThe smallest value that can be represented by this integer …\nThe minimum value.\nMinus one (multiplicative inverse) of this type.\nLess than zero.\nNon-EIP155. 27 or 28.\nThe value one. This is useful to have as a constant for …\nOne (multiplicative identity) of this type.\nThe parity of the signature, stored as either a V value …\nParity flag. True for odd.\nThe error type that is returned when parsing a signed …\nGreater than or equal to zero.\nAn Ethereum ECDSA signature.\nRaw input to be hashed.\nError that occurs when an invalid digit is encountered …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nSolidity contract functions are addressed using the first …\nEnum to represent the sign of a 256-bit signed integer.\nAn Ethereum ECDSA signature.\nErrors in signature parsing or verification.\nSigned integer wrapping a <code>ruint::Uint</code>.\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe <code>to</code> field of a transaction. Either a target address, or …\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n128-bit unsigned integer type, consisting of 2, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\nThe value zero. This is the only value that exists in all …\nArray of Zero bytes.\nArray of Zero bytes.\nZero (additive identity) of this type.\nComputes the absolute value of <code>self</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nAccrues the input into the bloom filter.\nAccrues the input into the bloom filter.\nIngests a log into the bloom filter.\nIngests a raw log into the bloom filter.\nCompute $\\mod{\\mathtt{self} + \\mathtt{rhs}}_…\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nType aliases for common primitive types.\nDouble precision logarithm.\nDouble precision decimal logarithm.\nDouble precision binary logarithm.\nConstruct from double precision binary logarithm.\nArithmetic shift right by <code>rhs</code> bits.\nReturns references to the address and selector of the …\nReturns the byte-array representation of this signature.\nReturns the sign character.\nConversion to i16 with overflow checking.\nConversion to i32 with overflow checking.\nConversion to i64 with overflow checking.\nConversion to i8 with overflow checking.\nConversion to isize with overflow checking.\nAccess the underlying store as a little-endian bytes.\nAccess the underlying store as a little-endian bytes with …\nAccess the underlying store as a little-endian slice of …\nAccess the underlying store as a mutable little-endian …\nView the array of limbs.\nView the array of limbs.\nAccess the array of limbs.\nReturns the checksum of a formatted address.\nConverts from <code>&amp;Sealed&lt;T&gt;</code> to <code>Sealed&lt;&amp;T&gt;</code>.\nReturns the checksum of a formatted address.\nConversion to u16 with overflow checking.\nConversion to u32 with overflow checking.\nConversion to u64 with overflow checking.\nConversion to u8 with overflow checking.\nConversion to usize with overflow checking.\nArithmetic shift left operation. Computes <code>self &lt;&lt; rhs</code>, …\nArithmetic shift right operation. Computes <code>self &gt;&gt; rhs</code> …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nReturns whether a specific bit is set.\nReturns whether a specific bit is set.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nReturns the dynamic length of this number in bits, …\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nReturn the least number of bits needed to represent the …\nConverts a sequence of string literals containing …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nReturns the dynamic length of this number in bytes, …\nConverts a sequence of string literals containing …\nReturns the chain ID associated with the V value, if this …\nReturns the chain ID associated with the V value, if this …\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nComputes <code>self + rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nReturns a specific byte, or <code>None</code> if <code>index</code> is out of range. …\nWrites the big-endian representation of the <code>Uint</code> to the …\nWrites the little-endian representation of the <code>Uint</code> to the …\nComputes <code>self / rhs</code>, returning <code>None</code> if <code>rhs == 0</code>.\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nConstruct a new integer from little-endian a slice of …\nCreates a <code>Signed</code> from an absolute value and a negative …\nReturns the logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nComputes <code>self * rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nComputes <code>-self</code>, returning <code>None</code> unless <code>self == 0</code>.\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nRaises self to the power of <code>exp</code>.\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nComputes <code>self % rhs</code>, returning <code>None</code> if <code>rhs == 0</code>.\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked left shift by <code>rhs</code> bits.\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked right shift by <code>rhs</code> bits.\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nComputes <code>self - rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nClone the inner item.\nMaps a <code>Sealed&lt;&amp;T&gt;</code> to a <code>Sealed&lt;T&gt;</code> by cloning the inner …\nCompile-time version of <code>contains</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nEquality at compile-time.\nReturns true if this bloom filter is a possible superset …\nReturns true if this bloom filter is a possible superset …\nTrue if the bloom filter contains a log with given address …\nTrue if the bloom filter contains a log with given address …\nWrites the big-endian representation of the <code>Uint</code> to the …\nWrites the little-endian representation of the <code>Uint</code> to the …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns a reference to the underlying data.\nThe plain data.\nThe log data.\nReturns a mutable reference to the underlying data.\nDecode an RLP-encoded VRS signature.\nComputes <code>self / rhs</code> rounding up.\nCalculates the quotient of Euclidean division of <code>self</code> by …\nComputes <code>self / rhs</code> and <code>self % rhs</code>.\nHash a message according to EIP-191 (version <code>0x01</code>).\nCreate <code>10**n</code> as this type.\nPad and squeeze the state.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nConverts a sequence of string literals containing …\nCalculates the checksum of an address into the buffer.\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConstruct a new <code>Uint</code> from the value.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an Ethereum function from an address and selector.\nConstructs the <code>Uint</code> from digits in the base <code>base</code> in …\nConstructs the <code>Signed</code> from digits in the base <code>base</code> in …\nConstructs the <code>Uint</code> from digits in the base <code>base</code> in …\nConverts a big-endian byte array of size exactly …\nConverts a big-endian byte array of size exactly …\nCreates a new integer from a big endian slice of bytes.\nParses a signature from a byte slice, with a v value\nConvert from a decimal string.\nConvert from a hex string.\nConverts a little-endian byte array of size exactly …\nConvert from an array in LE format\nCreates a new integer from a little endian slice of bytes.\nConstruct a new integer from little-endian a array of …\nConstruct a new integer from little-endian a array of …\nConstruct a new integer from little-endian a slice of …\nCoerces an unsigned integer into a signed one. If the …\nInstantiate from v, r, s.\nCreates a <code>Signature</code> from the serialized <code>r</code> and <code>s</code> scalar …\nInstantiate from a signature and recovery id\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new byte array from the given slice <code>src</code>.\nParse a string into a <code>Uint</code>.\nCreates an Ethereum function from an EVM word’s lower 24 …\nCompute the greatest common divisor of two <code>Uint</code>s.\n⚠️ Compute the greatest common divisor and the Bézout …\nReturns true if the signature is replay-protected by …\nReturns true if the signature is replay-protected by …\nGet the hash.\nGet the hash.\nCalculate the seal hash, this may be slow.\nMacro for converting sequence of string literals …\nGet the inner item.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner bytes array.\nReturns the inner bytes array.\nConsume the input, converting it to the hash.\nReturns the backing buffer.\nUnseal the inner item, discarding the hash.\nReturns the inner ECDSA signature.\nConvert to a array of limbs.\nConvert to a array of limbs.\nConsume and convert into a <code>LogData</code> object.\nDecompose into parts.\nReturns the signed integer as a unsigned integer. If the …\nSplits a Signed into its absolute value and negative flag.\nRight-pads the function to 32 bytes (EVM word size).\nCompute $\\mod{\\mathtt{self}^{-1}}_{\\mathtt{modulus}}$.\nComputes the inverse modulo $2^{\\mathtt{BITS}}$ of <code>self</code>, …\nInverts the parity.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns whether the sign is negative.\nDetermines if the integer is odd.\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns whether the sign is positive.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns true if the value is zero.\nReturns <code>true</code> if <code>self</code> is zero and <code>false</code> if the number is …\nSimple interface to the <code>Keccak-256</code> hash function.\nCompute the least common multiple of two <code>Uint</code>s or <code>None</code> if …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nReturns the size of this array in bytes.\nReturns the size of this array in bytes.\nReturns the logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nCompute the logs bloom filter for the given logs.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nSpecialised Bloom filter that sets three bits out of 2048, …\n<code>m3_2048</code> but with a pre-hashed input.\nRe-exports of map types and utilities.\nReturns the most significant 64 bits of the number and the …\nCompute $\\mod{\\mathtt{self} ⋅ \\mathtt{rhs}}_…\nMontgomery multiplication.\nCreates a new buffer.\nWraps the given byte array in this type.\nWraps the given byte array in this type.\nSeal the inner item.\nInstantiate a new signature from <code>r</code>, <code>s</code>, and <code>v</code> values.\nCreates a new <code>Keccak256</code> hasher.\nSeal the inner item, by reference.\nSeal a reference to the inner item with some function.\nInstantiate without performing the hash. This should be …\nSeal the inner item with some function.\nCalculates the smallest value greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nNormalizes the signature into “low S” form as …\nAttempts to normalize the v value to a boolean parity …\nInverts all the bits in the integer.\nComputes the absolute value of <code>self</code>.\nCalculates $\\mod{\\mathtt{self} + \\mathtt{rhs}}_{2^{BITS}}$.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> / <code>rhs</code>\nCalculates the quotient of Euclidean division …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nCreates a <code>Signed</code> from a sign and an absolute value. …\nCalculates the multiplication of self and rhs.\nCalculates <code>self</code> * <code>rhs</code>\nCalculates $\\mod{-\\mathtt{self}}_{2^{BITS}}$.\nNegates self, overflowing if this is equal to the minimum …\nRaises self to the power of <code>exp</code> and if the result would …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates <code>self</code> % <code>rhs</code>\nOverflowing Euclidean remainder. Calculates …\nLeft shift by <code>rhs</code> bits with overflow detection.\nShifts self left by <code>rhs</code> bits.\nRight shift by <code>rhs</code> bits with underflow detection.\nShifts self right by <code>rhs</code> bits.\nCalculates $\\mod{\\mathtt{self} - \\mathtt{rhs}}_{2^{BITS}}$.\nCalculates <code>self</code> - <code>rhs</code>\nRaises self to the power of <code>exp</code>, wrapping around on …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCompute $\\mod{\\mathtt{self}^{\\mathtt{rhs}}}_…\nReturns the <code>r</code> component of this signature.\nDetermines the recovery ID.\nReturns the recovery ID.\nRecovers an <code>Address</code> from this signature and the given …\nRecovers an <code>Address</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\n⚠️ Compute $\\mod{\\mathtt{self}}_{\\mathtt{modulus}}$.\nCalculates the least nonnegative remainder of …\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nReverses the order of bits in the integer. The least …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nLength of RLP RS field encoding\nLength of RLP V field encoding\nComputes the floor of the <code>degree</code>-th root of the number.\nShifts the bits to the left by a specified amount, <code>rhs</code>, …\nShifts the bits to the right by a specified amount, <code>rhs</code>, …\nReturns the <code>s</code> component of this signature.\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nComputes <code>self + rhs</code>, saturating at the numeric bounds …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nConstruct a new <code>Uint</code> from the value saturating the value …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nComputes <code>self * rhs</code>, saturating at the numeric bounds …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating negation. Computes <code>-self</code>, returning <code>MAX</code> if …\nRaises self to the power of <code>exp</code>, saturating on overflow.\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating left shift by <code>rhs</code> bits.\nComputes <code>self - rhs</code>, saturating at the numeric bounds …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nExamples\nGet the hash.\nSeal a borrowed object by calculating the hash. This may …\nSeal a borrowed object by calculating the hash. This may …\nInstantiate an unchecked seal. This should be used with …\nInstantiate an unchecked seal. This should be used with …\nSeal the object by calculating the hash. This may be slow.\nSeal the object by calculating the hash. This may be slow.\nInstantiate an unchecked seal. This should be used with …\nInstantiate an unchecked seal. This should be used with …\nSets a specific bit to a value.\nReturns the sign of self.\nDecompose into parts. Alias for <code>Self::into_parts</code>.\nMontgomery squaring.\nConverts an EIP-155 V value to a non-EIP-155 V value.\nPanics\nReturns the address and selector of the function.\nReturns an iterator over the base <code>base</code> digits of the …\nReturns an iterator over the base <code>base</code> digits of the …\nConverts the <code>Uint</code> to a big-endian byte array of size …\nConverts <code>self</code> to a big-endian byte array of size exactly …\nConverts the <code>Uint</code> to a big-endian byte vector with leading …\nConverts the <code>Uint</code> to a big-endian byte vector of size …\nConvert to a decimal string.\nApplies EIP-155.\nConvert to a hex string.\nReturns the inner ECDSA signature.\nConverts the <code>Uint</code> to a little-endian byte array of size …\nConverts <code>self</code> to a little-endian byte array of size exactly\nConverts the <code>Uint</code> to a little-endian byte vector with …\nConverts the <code>Uint</code> to a little-endian byte vector of size …\nConvert into a <code>LogData</code> object.\nConvert to a parity bool, dropping any V information.\nReturns the checksum of a formatted address.\nReturn the corresponding u64 V value.\nReturns the number of trailing ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of leading zeros in the binary …\nParses a raw signature which is expected to be 65 bytes …\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nTries to create a <code>Vec</code> containing the arguments.\nCompute the two’s complement of this number.\nShortcut for <code>val.try_into().unwrap()</code>.\nShortcut for <code>self.try_into().unwrap()</code>.\nUnseal the inner item, discarding the hash. Alias for …\nComputes the absolute value of <code>self</code> without any wrapping …\nAbsorbs additional input. Can be called multiple times.\nCommon Ethereum utilities.\nReturns the recovery ID as a <code>u8</code>.\nCalculates the complete product <code>self * rhs</code> without the …\nApplies EIP-155 with the given chain ID.\nModifies the recovery ID by applying EIP-155 to a <code>v</code> value.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nSets the recovery ID by normalizing a <code>v</code> value.\nModifies the recovery ID by dropping any [EIP-155] v …\nWrap a fixed-size byte array in a newtype, delegating all …\nWrapping absolute value. Computes <code>self.abs()</code>, wrapping …\nComputes <code>self + rhs</code>, wrapping around at the boundary of …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nComputes <code>self / rhs</code> rounding down.\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nConstruct a new <code>Uint</code> from the value saturating the value …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nComputes <code>self * rhs</code>, wrapping around at the boundary of …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nComputes <code>-self</code>, wrapping around at the boundary of the …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nRaises self to the power of <code>exp</code>, wrapping around on …\nRaises self to the power of <code>exp</code>, wrapping around at the …\nComputes <code>self % rhs</code>.\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nLeft shift by <code>rhs</code> bits.\nWrapping shift left. Computes <code>self &lt;&lt; rhs</code>, returning 0 if …\nRight shift by <code>rhs</code> bits.\nWrapping shift right. Computes <code>self &gt;&gt; rhs</code>, returning 0 if …\nComputes <code>self - rhs</code>, wrapping around at the boundary of …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nExamples\nWrite R and S to an RLP buffer in progress.\nWrite the V to an RLP buffer without using EIP-155.\nWrite the VRS to the output. The V will always be 27 or 28.\nReturn the y-parity as a boolean.\nReturn the y-parity as 0 or 1\nReturn the y-parity byte as 27 or 28, in the case of a …\n128-byte fixed byte-array type.\n16-byte fixed byte-array type.\n2-byte fixed byte-array type.\n24-byte fixed byte-array type.\n256-byte fixed byte-array type.\n28-byte fixed byte-array type.\n32-byte fixed byte-array type.\n4-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\n1-byte fixed byte-array type.\n12-byte fixed byte-array type.\nA block hash.\nA block number.\nA block timestamp.\nChain identifier type (introduced in EIP-155).\nThe 0-bit signed integer type, capable of representing 0.\nThe 1-bit signed integer type, capable of representing 0 …\n104-bit signed integer type, consisting of 2, 64-bit limbs.\n112-bit signed integer type, consisting of 2, 64-bit limbs.\n120-bit signed integer type, consisting of 2, 64-bit limbs.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n136-bit signed integer type, consisting of 3, 64-bit limbs.\n144-bit signed integer type, consisting of 3, 64-bit limbs.\n152-bit signed integer type, consisting of 3, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n168-bit signed integer type, consisting of 3, 64-bit limbs.\n176-bit signed integer type, consisting of 3, 64-bit limbs.\n184-bit signed integer type, consisting of 3, 64-bit limbs.\n192-bit signed integer type, consisting of 3, 64-bit limbs.\n200-bit signed integer type, consisting of 4, 64-bit limbs.\n208-bit signed integer type, consisting of 4, 64-bit limbs.\n216-bit signed integer type, consisting of 4, 64-bit limbs.\n224-bit signed integer type, consisting of 4, 64-bit limbs.\n232-bit signed integer type, consisting of 4, 64-bit limbs.\n24-bit signed integer type, consisting of 1, 64-bit limbs.\n240-bit signed integer type, consisting of 4, 64-bit limbs.\n248-bit signed integer type, consisting of 4, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n40-bit signed integer type, consisting of 1, 64-bit limbs.\n48-bit signed integer type, consisting of 1, 64-bit limbs.\n512-bit signed integer type, consisting of 8, 64-bit limbs.\n56-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n72-bit signed integer type, consisting of 2, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\n80-bit signed integer type, consisting of 2, 64-bit limbs.\n88-bit signed integer type, consisting of 2, 64-bit limbs.\n96-bit signed integer type, consisting of 2, 64-bit limbs.\nSolidity contract functions are addressed using the first …\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n104-bit unsigned integer type, consisting of 2, 64-bit …\n112-bit unsigned integer type, consisting of 2, 64-bit …\n120-bit unsigned integer type, consisting of 2, 64-bit …\n128-bit unsigned integer type, consisting of 2, 64-bit …\n136-bit unsigned integer type, consisting of 3, 64-bit …\n144-bit unsigned integer type, consisting of 3, 64-bit …\n152-bit unsigned integer type, consisting of 3, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n168-bit unsigned integer type, consisting of 3, 64-bit …\n176-bit unsigned integer type, consisting of 3, 64-bit …\n184-bit unsigned integer type, consisting of 3, 64-bit …\n192-bit unsigned integer type, consisting of 3, 64-bit …\n200-bit unsigned integer type, consisting of 4, 64-bit …\n<code>Uint</code> for <code>2048</code> bits.\n208-bit unsigned integer type, consisting of 4, 64-bit …\n216-bit unsigned integer type, consisting of 4, 64-bit …\n224-bit unsigned integer type, consisting of 4, 64-bit …\n232-bit unsigned integer type, consisting of 4, 64-bit …\n24-bit unsigned integer type, consisting of 1, 64-bit …\n240-bit unsigned integer type, consisting of 4, 64-bit …\n248-bit unsigned integer type, consisting of 4, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n40-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n48-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n56-bit unsigned integer type, consisting of 1, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n72-bit unsigned integer type, consisting of 2, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\n80-bit unsigned integer type, consisting of 2, 64-bit …\n88-bit unsigned integer type, consisting of 2, 64-bit …\n96-bit unsigned integer type, consisting of 2, 64-bit …\n<code>HashMap</code> optimized for hashing <code>Address</code>.\n<code>HashSet</code> optimized for hashing <code>Address</code>.\n<code>HashMap</code> optimized for hashing <code>B256</code>.\n<code>HashSet</code> optimized for hashing <code>B256</code>.\nThe default <code>BuildHasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nThe default <code>Hasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nA view into a single entry in a map, which may either be …\n<code>BuildHasher</code> optimized for hashing fixed-size byte arrays.\n<code>Hasher</code> optimized for hashing fixed-size byte arrays.\n<code>HashMap</code> optimized for hashing fixed-size byte arrays.\n<code>HashSet</code> optimized for hashing fixed-size byte arrays.\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nAn occupied entry.\n<code>HashMap</code> optimized for hashing <code>Selector</code>.\n<code>HashSet</code> optimized for hashing <code>Selector</code>.\nA vacant entry.\nProvides in-place mutable access to an occupied entry …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA hash map implemented with quadratic probing and SIMD …\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nSets the value of the entry, and returns an <code>OccupiedEntry</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a reference to this entry’s key.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nEnsures a value is in the entry by inserting, if empty, …\nThe default <code>Hasher</code> used by <code>RandomState</code>.\nA draining iterator over the entries of a <code>HashMap</code>.\nA view into a single entry in a map, which may either be …\nA draining, filtering iterator over the entries of a …\nA hash map implemented with quadratic probing and SIMD …\nAn owning iterator over the entries of a <code>HashMap</code>.\nAn owning iterator over the keys of a <code>HashMap</code>.\nAn owning iterator over the values of a <code>HashMap</code>.\nAn iterator over the entries of a <code>HashMap</code>.\nA mutable iterator over the entries of a <code>HashMap</code>.\nAn iterator over the keys of a <code>HashMap</code>.\nAn occupied entry.\nAn occupied entry.\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nThe error returned by <code>try_insert</code> when the key already …\n<code>RandomState</code> is the default state for <code>HashMap</code> types.\nA builder for computing where in a HashMap a key-value …\nA builder for computing where in a HashMap a key-value …\nA view into a single entry in a map, which may either be …\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nA vacant entry.\nA vacant entry.\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nAn iterator over the values of a <code>HashMap</code>.\nA mutable iterator over the values of a <code>HashMap</code>.\nProvides in-place mutable access to an occupied entry …\nReturns the number of elements the map can hold without …\nClears the map, removing all key-value pairs. Keeps the …\nReturns <code>true</code> if the map contains a value for the specified …\nCreates an empty <code>HashMap&lt;K, V, S&gt;</code>, with the <code>Default</code> value …\nConstructs a new <code>RandomState</code>.\nCreates a new <code>DefaultHasher</code> using <code>new</code>. See its …\nClears the map, returning all key-value pairs as an …\nGets the given key’s corresponding entry in the map for …\nThe entry in the map that was already occupied.\nCreates an iterator which uses a closure to determine if …\nReturns the argument unchanged.\nConverts a <code>[(K, V); N]</code> into a <code>HashMap&lt;K, V&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>RawEntryMut</code> from the given hash.\nAccess an entry by hash.\nConstructs a <code>HashMap&lt;K, V&gt;</code> from an iterator of key-value …\nCreates a <code>RawEntryMut</code> from the given key.\nAccess an entry by key.\nCreates a <code>RawEntryMut</code> from the given key and its hash.\nAccess an entry by a key and its hash.\nReturns a reference to the value corresponding to the key.\nGets a reference to the value in the entry.\nGets a reference to the value in the entry.\nReturns the key-value pair corresponding to the supplied …\nGets a reference to the key and value in the entry.\nGets a mutable reference to the key and value in the entry.\nAttempts to get mutable references to <code>N</code> values in the map …\nAttempts to get mutable references to <code>N</code> values in the map …\nReturns a mutable reference to the value corresponding to …\nGets a mutable reference to the value in the entry.\nGets a mutable reference to the value in the entry.\nReturns a reference to the map’s <code>BuildHasher</code>.\nReturns a reference to the value corresponding to the …\nInserts a key-value pair into the map.\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the VacantEntry’s key, …\nSets the value of the entry, and returns the entry’s old …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nConverts the entry into a mutable reference to the key in …\nTake ownership of the key.\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nCreates a consuming iterator visiting all the keys in …\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nCreates a consuming iterator visiting all the values in …\nReturns <code>true</code> if the map contains no elements.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all key-value pairs in arbitrary …\nGets a reference to the key in the entry.\nGets a reference to the key in the entry.\nGets a reference to the key that would be used when …\nGets a mutable reference to the key in the entry.\nAn iterator visiting all keys in arbitrary order. The …\nReturns the number of elements in the map.\nCreates an empty <code>HashMap</code>.\nConstructs a new <code>RandomState</code> that is initialized with …\nCreates a new <code>DefaultHasher</code>.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nCreates a raw immutable entry builder for the HashMap.\nCreates a raw entry builder for the HashMap.\nRemoves a key from the map, returning the value at the key …\nTakes the value out of the entry, and returns it.\nTakes the value out of the entry, and returns it.\nRemoves a key from the map, returning the stored key and …\nTake the ownership of the key and value from the map.\nTake the ownership of the key and value from the map.\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the map with a lower limit. It …\nShrinks the capacity of the map as much as possible. It …\nTries to insert a key-value pair into the map, and returns …\nTries to reserve capacity for at least <code>additional</code> more …\nThe value which was not inserted, because the entry was …\nAn iterator visiting all values in arbitrary order. The …\nAn iterator visiting all values mutably in arbitrary order.\nCreates an empty <code>HashMap</code> with at least the specified …\nCreates an empty <code>HashMap</code> with at least the specified …\nCreates an empty <code>HashMap</code> which will use the given hash …\nA lazy iterator producing elements in the difference of …\nA draining iterator over the items of a <code>HashSet</code>.\nA view into a single entry in a set, which may either be …\nA draining, filtering iterator over the items of a <code>HashSet</code>.\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nA lazy iterator producing elements in the intersection of …\nAn owning iterator over the items of a <code>HashSet</code>.\nAn iterator over the items of a <code>HashSet</code>.\nAn occupied entry.\nA view into an occupied entry in a <code>HashSet</code>. It is part of …\nA lazy iterator producing elements in the symmetric …\nA lazy iterator producing elements in the union of <code>HashSet</code>…\nA vacant entry.\nA view into a vacant entry in a <code>HashSet</code>. It is part of the …\nReturns the intersection of <code>self</code> and <code>rhs</code> as a new …\nReturns the union of <code>self</code> and <code>rhs</code> as a new <code>HashSet&lt;T, S&gt;</code>.\nReturns the symmetric difference of <code>self</code> and <code>rhs</code> as a new …\nReturns the number of elements the set can hold without …\nClears the set, removing all values.\nOverwrites the contents of <code>self</code> with a clone of the …\nReturns <code>true</code> if the set contains a value.\nCreates an empty <code>HashSet&lt;T, S&gt;</code> with the <code>Default</code> value for …\nVisits the values representing the difference, i.e., the …\nClears the set, returning all elements as an iterator. …\nGets the given value’s corresponding entry in the set …\nCreates an iterator which uses a closure to determine if a …\nReturns the argument unchanged.\nConverts a <code>[T; N]</code> into a <code>HashSet&lt;T&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value in the set, if any, that …\nReturns a reference to this entry’s value.\nGets a reference to the value in the entry.\nGets a reference to the value that would be used when …\nInserts the given <code>value</code> into the set if it is not present, …\nInserts a value computed from <code>f</code> into the set if the given …\nReturns a reference to the set’s <code>BuildHasher</code>.\nAdds a value to the set.\nSets the value of the entry, and returns an OccupiedEntry.\nSets the value of the entry with the VacantEntry’s value.\nVisits the values representing the intersection, i.e., the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nTake ownership of the value.\nReturns <code>true</code> if <code>self</code> has no elements in common with <code>other</code>. …\nReturns <code>true</code> if the set contains no elements.\nReturns <code>true</code> if the set is a subset of another, i.e., <code>other</code>…\nReturns <code>true</code> if the set is a superset of another, i.e., …\nAn iterator visiting all elements in arbitrary order. The …")