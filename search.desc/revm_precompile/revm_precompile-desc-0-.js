searchState.loadedDescShard("revm_precompile", 0, "revm-precompile\nAn Ethereum address, 20 bytes in length.\n32-byte fixed byte-array type.\nThe input length is not exactly 192 bytes.\nThe input length is not exactly 192 bytes.\nThe commitment does not match the versioned hash.\nThe commitment does not match the versioned hash.\nThe proof verification failed.\nThe proof verification failed.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nSimilar to Standard but takes reference to environment.\nContains the error value\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nA log consists of an address, and some log data.\nContains the success value\nCatch-all variant for other errors.\nCatch-all variant for other errors.\nout of gas is the main error. Others are here just for …\nout of gas is the main error. Others are here just for …\nPrecompile and its handlers.\nPrecompile errors.\nPrecompile execution output\nA precompile operation result.\nStandard simple precompile that takes input and gas limit.\nStateful precompile that is Arc over <code>StatefulPrecompile</code> …\nMutable stateful precompile that is Box over …\nStateful precompile trait. It is used to create a arc …\nArc over stateful precompile.\nBox over mutable stateful precompile\nMutable stateful precompile trait. It is used to create a …\nArray of Zero bytes.\nReturns reference of address.\nThe address which emitted this log.\nReturns an iterator over the precompiles addresses.\nReturns the precompiles addresses as a set.\nReturns precompiles for Berlin spec.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nOutput bytes.\nReturns precompiles for Byzantium spec.\nCall the precompile with the given input and gas limit and …\nCall the precompile with the given input and gas limit and …\nReturns precompiles for Cancun spec.\nCompile-time equality. NOT constant-time equality.\nIs the given address a precompile.\nCreates a new <code>Bytes</code> instance from a slice by copying it.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nComputes the <code>create</code> address for this address and nonce:\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the <code>CREATE2</code> address of a smart contract as …\nThe log data.\nCreates a new empty log.\nExtends the precompiles with the given precompiles.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an ECDSA signing key to its corresponding …\nConverts an ECDSA verifying key to its corresponding …\nInstantiate by hashing public key bytes.\nCreate a new byte array from the given slice <code>src</code>.\nReturns the appropriate precompile Spec for the primitive …\nCreates a new <code>Bytes</code> from a static slice.\nCreates an Ethereum address from an EVM word’s upper 20 …\nGas used by the precompile.\nReturns the precompile for the given address.\nReturns the precompile for the given address.\nReturns precompiles for Homestead spec.\nReturns inner HashMap of precompiles.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the type and returns all precompile addresses.\nReturns the inner bytes array.\nLeft-pads the address to 32 bytes (EVM word size).\nIs the precompiles list empty.\nReturns true if the error is out of gas.\nReturns precompiles for Istanbul spec.\nReturns the precompiles for the latest spec.\nCreate a new byte array from the given slice <code>src</code>, …\nReturns the number of precompiles.\nReturns the size of this array in bytes.\nReturns the precompiles for the given spec.\nWraps the given byte array in this type.\nReturns new precompile output with the given gas used and …\nCreates a new empty <code>Bytes</code>.\nCreates a new log.\nCreates a new log from an deserialized event.\nCreates a new log.\nCreate a new stateful precompile.\nCreate a new mutable stateful precompile.\nCreates a new log.\nReturns an other error with the given message.\nParse an Ethereum address, verifying its EIP-55 checksum.\nReturns precompiles for Prague spec.\nReturns reference of precompile.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nReserialize the data.\nCreate a new byte array from the given slice <code>src</code>, …\nReturns a slice of self for the provided range.\nReturns a slice of self that is equivalent to the given …\nSplits the bytes into two at the given index.\nSplits the bytes into two at the given index.\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into …\nConst function for making an address by concatenating the …\nCreates a new byte array with the last byte set to <code>x</code>.\nreference: https://eips.ethereum.org/EIPS/eip-152 input …\ngot IV from: …\nSIGMA from spec: …\nG function: https://tools.ietf.org/html/rfc7693#section-3.1\nReturns the BLS12-381 precompiles with their addresses.\nBLS12_G1ADD precompile address.\nEIP-2537 BLS12_G1ADD precompile.\nBLS12_G1MSM precompile address.\nDiscounts table for G1 MSM as a vector of pairs …\nEIP-2537 BLS12_G1MSM precompile.\nBLS12_G2ADD precompile address.\nEIP-2537 BLS12_G2ADD precompile.\nBLS12_G2MSM precompile address.\nEIP-2537 BLS12_G2MSM precompile.\nBLS12_MAP_FP2_TO_G2 precompile address.\nEIP-2537 BLS12_MAP_FP2_TO_G2 precompile.\nBLS12_MAP_FP_TO_G1 precompile address.\nEIP-2537 BLS12_MAP_FP_TO_G1 precompile.\nBLS12_PAIRING precompile address.\nEIP-2537 BLS12_PAIRING precompile.\nInput length for the add operation. <code>ADD</code> takes two …\nInput length for the multiplication operation. <code>MUL</code> takes …\nPair element length. <code>PAIR</code> elements are composed of an …\nCreates a new <code>G1</code> point from the given <code>x</code> and <code>y</code> coordinates.\nReads a single <code>Fq</code> from the input slice.\nReads the <code>x</code> and <code>y</code> points from the input slice.\nFatal precompile that returns Fatal error on precompile …\nDisable kzg precompile. This will return Fatal error on …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new fatal precompile\nCreate a new stateful fatal precompile\nComputes the RIPEMD-160 hash of the input data.\nComputes the SHA-256 hash of the input data.\nThe base cost of the operation.\nThe cost per word.\nTakes the input bytes, copies them, and returns it as the …\n…\n<code>VERSIONED_HASH_VERSION_KZG ++ sha256(commitment)[1..]</code>\nRun kzg point evaluation precompile.\nSee: https://eips.ethereum.org/EIPS/eip-198 See: …\nConverts a boolean to a left-padded <code>B256</code> value.\nConverts a boolean to a left-padded 32-byte <code>Bytes</code> value.\nLeft-pads the given slice with zeroes until <code>LEN</code>.\nLeft-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice with zeroes until <code>LEN</code>.\nRight-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>LEN</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>len</code>.")